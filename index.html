<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SIMUPASIR ‚Äî guardar/importar + men√∫</title>

<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#003366">
<link rel="icon" href="./icons/icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="./icons/icon-192.png">

<style>
  :root{
    --sidebar:#f3e5ab;
    --node:#fff8dc;
    --pin:#222;
    --wire:#000;
    --neon:#00ff66;
    --accent:#444;

    --pin-long:24px;
    --pin-hit-h:28px;
    --pin-visible-h:7px;
    --round-pin:28px;

    --workspace-size:5000px;
  }

  html,body{height:100%}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;display:flex;height:100vh;overflow:hidden;background:#fff}

  /* Top bar */
  #topbar{
    position:fixed;left:0;right:0;top:0;height:48px;background:#003366;color:#fff;
    display:flex;align-items:center;gap:8px;padding:0 10px;z-index:300;
    box-shadow:0 2px 10px rgba(0,0,0,.2)
  }
  #topbar .title{font-weight:800;letter-spacing:.5px;margin-right:auto}
  #topbar button, #topbar label.btn{
    background:#fff;color:#003366;border:0;border-radius:10px;padding:6px 10px;font-weight:800;cursor:pointer
  }
  #fileInput{display:none}

  /* Layout */
  #sidebar{width:150px;background:var(--sidebar);padding:10px;border-right:3px solid #bdb089;display:flex;flex-direction:column;gap:8px;box-sizing:border-box;z-index:60;margin-top:48px}
  #sidebar > div[style*="font-weight"]{font-size:13px}
  .component{background:var(--node);border:2px solid #7a7a7a;border-radius:8px;padding:6px;text-align:center;cursor:grab;user-select:none;font-weight:700;font-size:20px;line-height:1.05;box-shadow:0 2px 0 rgba(0,0,0,.06)}
  .component.selected{outline:3px solid #0078d7;outline-offset:2px}

  body.hide-sidebar #sidebar{display:none}

  /* Canvas */
  #canvas{flex:1;background:#fff;position:relative;overflow:hidden;touch-action:none;margin-top:48px}
  #workspace{position:absolute;top:0;left:0;width:var(--workspace-size);height:var(--workspace-size);transform-origin:0 0;background:transparent}

  /* Bloques */
  .node{position:absolute;background:var(--node);border:3px solid var(--accent);border-radius:10px;width:150px;height:225px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:move;user-select:none;padding:8px;box-sizing:border-box;box-shadow:0 6px 0 rgba(0,0,0,.06);z-index:10;touch-action:none}
  .node.active-border{border-color:#00a36c}
  .label{font-weight:900;margin-bottom:6px;pointer-events:none;color:#222;font-size:60px;line-height:1.05}
  .selected{box-shadow:0 10px 18px rgba(0,0,0,.12);border-color:#0058a3!important;transform:translateY(-2px)}

  /* Badge B001‚Ä¶ */
  .badge{position:absolute;top:6px;left:6px;padding:4px 10px;border-radius:12px;border:2px solid #003366;background:#fff;color:#003366;font-weight:900;font-size:18px;line-height:1;pointer-events:none;user-select:none;box-shadow:0 2px 0 rgba(0,0,0,.06)}

  /* Pines */
  .terminal{position:absolute;cursor:pointer;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,.08);height:var(--pin-hit-h);background:transparent}
  .terminal::before{content:"";position:absolute;left:0;right:0;top:50%;transform:translateY(-50%);height:var(--pin-visible-h);border-radius:4px;background:var(--pin);display:block}
  .terminal.input{width:var(--pin-long);left:calc(-1 * var(--pin-long))}
  .terminal.output{width:var(--pin-long);right:calc(-1 * var(--pin-long));top:50%;transform:translateY(-50%)}
  .terminal.output.out-round{width:var(--round-pin);right:calc(-1 * var(--round-pin))}
  .terminal.output.out-round::before{width:var(--round-pin);height:var(--round-pin);border-radius:50%;background:#000;left:auto;right:0}
  .terminal.pin-selected::before{background:#0078d7!important;box-shadow:0 0 0 3px rgba(0,120,215,.25)}
  .terminal.pin-target{outline:2px solid #0078d7;outline-offset:2px}
  .terminal.signal-on::before{background:var(--neon)!important}

  .term-label{position:absolute;left:calc(-1 * var(--pin-long) - 36px);width:40px;text-align:right;font-size:12px;color:#222;user-select:none}

  /* Cables */
  #wires{position:absolute;top:0;left:0;width:var(--workspace-size);height:var(--workspace-size);pointer-events:auto;z-index:6}
  .wire-hit{fill:none;stroke:#000;stroke-width:40;stroke-opacity:0;vector-effect:non-scaling-stroke;pointer-events:stroke;stroke-linecap:round}
  .wire-path{fill:none;stroke:var(--wire);stroke-width:5;vector-effect:non-scaling-stroke;pointer-events:stroke}
  .wire-path.signal{stroke:var(--neon);stroke-width:6;filter:drop-shadow(0 0 8px rgba(0,255,102,.25))}
  .wire-path.selected{stroke:#0078d7;stroke-width:6}
  .wire-path.ghost{stroke-dasharray:6 6;opacity:.75}

  /* Junta (hub) negra en salidas */
  .hub-dot{fill:#000;stroke:#000;stroke-width:1.5;pointer-events:all;cursor:grab}
  .hub-hit{fill:#000;fill-opacity:0;pointer-events:all;cursor:grab}

  /* Handles (nodos) */
  .bend-handle{fill:#fff;stroke:#0078d7;stroke-width:2.5px;r:11;cursor:grab;pointer-events:all}
  .bend-handle.dragging{fill:#e6f3ff}
  .bend-hit{fill:#000;fill-opacity:0;r:24;pointer-events:all}

  /* Etiquetas */
  .conn-tag{
    position:absolute;transform:translate(-50%,-50%);background:#fff;border:3px solid #003366;color:#003366;border-radius:12px;padding:6px 12px;font-weight:900;
    font-size:27px;line-height:1;box-shadow:0 2px 0 rgba(0,0,0,.06);user-select:none;z-index:20;cursor:grab
  }
  .conn-tag-src{background:#003366;color:#fff}
  .conn-tag.signal{border-color:var(--neon); color:#0b7a3b; box-shadow:0 0 10px rgba(0,255,102,.25)}
  .conn-tag-src.signal{background:#00a36c;color:#fff}
  .conn-tag.selected{outline:3px solid #0078d7;outline-offset:2px}

  /* Controles inferiores */
  #controls{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);background:var(--sidebar);padding:8px 12px;border-radius:10px;border:2px solid #bdb089;display:flex;gap:10px;align-items:center;z-index:200}
  #controls button{padding:8px 10px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:700;cursor:pointer}
  #zoomIn,#zoomOut{padding:6px 10px}
  #simulate.sim-on{background:#00a36c;color:#fff;border-color:#008255}

  .q-indicator{width:18px;height:18px;border-radius:50%;background:#444;margin-top:8px;pointer-events:none;border:2px solid #222}
  .q-indicator.on{background:var(--neon);box-shadow:0 0 8px rgba(0,255,102,.45)}

  #brand{position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.06);padding:8px 12px;border-radius:8px;font-weight:900;letter-spacing:1px;z-index:60;box-shadow:0 6px 0 rgba(0,0,0,.04)}

  #installBtn{display:none;position:fixed;right:12px;bottom:80px;z-index:210;background:#003366;color:#fff;border:none;padding:10px 14px;border-radius:10px;font-weight:900;cursor:pointer;box-shadow:0 6px 0 rgba(0,0,0,.12)}

  /* FAB y paleta en m√≥vil (la dejamos por si la usas) */
  #fabPalette{position:fixed;left:12px;bottom:12px;z-index:210;background:#003366;color:#fff;border:none;padding:12px 14px;border-radius:999px;font-weight:900;cursor:pointer;box-shadow:0 6px 0 rgba(0,0,0,.12);display:none}
  #paletteModal{position:fixed;inset:0;display:none;z-index:220;background:rgba(0,0,0,.35)}
  #paletteSheet{position:absolute;left:0;right:0;bottom:0;background:#fff;border-radius:16px 16px 0 0;padding:14px;border-top:3px solid #003366}
  #paletteGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .pick{background:#fff8dc;border:2px solid #7a7a7a;border-radius:10px;padding:10px;font-weight:800;font-size:20px;text-align:center;cursor:pointer}

  /* Men√∫ contextual del cable */
  #wireMenu{position:fixed;z-index:230;display:none;background:#fff;border:2px solid #003366;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.18);overflow:hidden}
  #wireMenu button{display:block;width:100%;background:#fff;border:0;border-bottom:1px solid #e5e5e5;padding:10px 14px;font-weight:800;cursor:pointer;text-align:left}
  #wireMenu button:last-child{border-bottom:0}
  #wireMenu button:hover{background:#f5f9ff}

  @supports(padding:max(0px)){
    #controls{bottom:calc(12px + env(safe-area-inset-bottom))}
    #installBtn{bottom:calc(80px + env(safe-area-inset-bottom))}
    #fabPalette{bottom:calc(12px + env(safe-area-inset-bottom))}
  }
  @media (max-width:720px){
    #sidebar{display:none}
    #fabPalette{display:block}
  }
</style>
</head>
<body>

  <!-- TOPBAR -->
  <div id="topbar">
    <div class="title">SIMUPASIR</div>
    <button id="toggleLib">Ocultar biblioteca</button>
    <button id="btnSave">Guardar</button>
    <label class="btn" for="fileInput">Importar</label>
    <input id="fileInput" type="file" accept=".json,.simupasir.json" />
  </div>

  <!-- SIDEBAR -->
  <div id="sidebar">
    <div style="font-weight:900">SIMUPASIR ‚Äî Componentes</div>
    <div class="component" draggable="true" data-type="input">Entrada (I)</div>
    <div class="component" draggable="true" data-type="output">Salida (Q)</div>
    <div class="component" draggable="true" data-type="M">Memoria (M)</div>
    <div style="height:4px"></div>
    <div class="component" draggable="true" data-type="and">AND</div>
    <div class="component" draggable="true" data-type="or">OR</div>
    <div class="component" draggable="true" data-type="not">NOT</div>
    <div class="component" draggable="true" data-type="nand">NAND</div>
    <div class="component" draggable="true" data-type="nor">NOR</div>
    <div class="component" draggable="true" data-type="xor">XOR</div>
    <div class="component" draggable="true" data-type="xnor">XNOR</div>
    <div style="height:4px"></div>
    <div class="component" draggable="true" data-type="sr">SR (Set/Reset)</div>
    <div style="flex:1"></div>
    <div style="font-size:11px;color:#333">Arrastra (PC) o usa el bot√≥n üß©</div>
  </div>

  <!-- CANVAS -->
  <div id="canvas">
    <div id="workspace">
      <svg id="wires" xmlns="http://www.w3.org/2000/svg" width="5000" height="5000" viewBox="0 0 5000 5000" preserveAspectRatio="none"></svg>
    </div>

    <div id="controls">
      <button id="simulate">Simular</button>
      <button id="stop">Detener</button>
      <button id="deleteBtn">Eliminar</button>
      <button id="zoomOut" title="Alejar">‚àí</button>
      <button id="zoomIn" title="Acercar">Ôºã</button>
    </div>
  </div>

  <div id="brand">SIMUPASIR</div>
  <button id="installBtn">Instalar SIMUPASIR</button>
  <button id="fabPalette">üß© Bloques</button>

  <!-- Modal paleta -->
  <div id="paletteModal" aria-hidden="true">
    <div id="paletteSheet">
      <div style="font-weight:900;margin-bottom:10px;color:#003366">Elige un bloque</div>
      <div id="paletteGrid"></div>
      <div style="margin-top:10px;display:flex;justify-content:center">
        <button id="closePalette" style="padding:8px 12px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:700">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- Men√∫ contextual del cable -->
  <div id="wireMenu">
    <button id="menuAddNode">‚ûï Crear nodo para acomodar</button>
    <button id="menuMakeLabel">üè∑Ô∏è Crear etiqueta y eliminar cable</button>
  </div>

<script>
/* ===== PWA b√°sico ===== */
let deferredPrompt=null;
const installBtn=document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt',(e)=>{ e.preventDefault(); deferredPrompt=e; installBtn.style.display='block'; });
installBtn.addEventListener('click', async()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); await deferredPrompt.userChoice; installBtn.style.display='none'; deferredPrompt=null; });
if('serviceWorker' in navigator){ window.addEventListener('load',()=>{ navigator.serviceWorker.register('./service-worker.js').catch(console.error); }); }

/* ===== SIMUPASIR ===== */
const canvas = document.getElementById("canvas");
const workspace = document.getElementById("workspace");
const wiresSVG = document.getElementById("wires");
const components = document.querySelectorAll(".component");

let nodes=[], connections=[], pendingOutput=null, pendingGhost=null;
let simulation=false;
let inputCount=0, outputCount=0, memoryCount=0;
let blockCodeCount=0;  // B001, B002, ...
let scale=1, panX=0, panY=0, isPanning=false, panStartX=0, panStartY=0;
let simTimer=null, SCAN_MS=60;
let selectedNode=null, selectedConn=null;
let selectedTag=null;
let selectedBranch=null;
let draggingBend=null;
let longPressTimer=null;
let currentToPlace=null;
let selectedPinEl=null;

/* Hubs (juntas) por pin de salida */
const outputHubs = new WeakMap(); // pinEl -> { x,y, dot, hit, stemPath, pin, branches:Set }

function zpad(n,len=3){ return String(n).padStart(len,'0'); }
function logoLabelForType(type){
  switch(type){
    case 'and':  return '&';
    case 'nand': return '&';
    case 'or':   return '‚â•1';
    case 'nor':  return '‚â•1';
    case 'not':  return '1';
    case 'xor':  return '=1';
    case 'xnor': return '‚â†1';
    case 'sr':   return 'S/R';
    case 'M':    return 'M';
    default:     return (type||'').toUpperCase();
  }
}
function clientToWorkspace(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  return { x:(clientX-rect.left-panX)/scale, y:(clientY-rect.top-panY)/scale };
}
function terminalEdge(term){
  const rect = term.getBoundingClientRect();
  const wsRect = workspace.getBoundingClientRect();
  const isInput=term.classList.contains('input');
  const isOutput=term.classList.contains('output');
  const xScreen = isInput ? rect.left : (isOutput ? rect.right : rect.left + rect.width/2);
  const yScreen = rect.top + rect.height/2;
  return { x:(xScreen-wsRect.left)/scale, y:(yScreen-wsRect.top)/scale };
}

/* Zoom & Pan */
canvas.addEventListener("wheel", e=>{ e.preventDefault(); setZoom(scale + (e.deltaY>0?-0.08:0.08)); });
function setZoom(next){
  const rect = canvas.getBoundingClientRect();
  const cx = rect.left+rect.width/2, cy = rect.top+rect.height/2;
  const fx=(cx-rect.left-panX)/scale, fy=(cy-rect.top-panY)/scale;
  const newScale = Math.max(.25, Math.min(3,next));
  panX = cx-rect.left - fx*newScale; panY = cy-rect.top - fy*newScale; scale=newScale;
  updateTransform(); updateConnections();
}
function updateTransform(){ workspace.style.transform=`translate(${panX}px,${panY}px) scale(${scale})`; }
workspace.addEventListener("mousedown", e=>{
  if(e.target===workspace){
    if(e.button===0) clearSelection();
    isPanning=true; panStartX=e.clientX-panX; panStartY=e.clientY-panY;
    document.addEventListener("mousemove",doPan); document.addEventListener("mouseup",endPan);
  }
});
function doPan(e){ if(!isPanning) return; panX=e.clientX-panStartX; panY=e.clientY-panStartY; updateTransform(); updateConnections(); }
function endPan(){ isPanning=false; document.removeEventListener("mousemove",doPan); document.removeEventListener("mouseup",endPan); }

/* Touch pan/pinch */
let touchPan={active:false,id:null,startClientX:0,startClientY:0,startPanX:0,startPanY:0};
let pinch={active:false,startDist:0,startScale:1,cx:0,cy:0};
workspace.addEventListener('touchstart', e=>{
  if(e.touches.length===1 && !pinch.active){
    const t=e.touches[0];
    const target=document.elementFromPoint(t.clientX,t.clientY);
    if(target===workspace || target===wiresSVG){
      touchPan={active:true,id:t.identifier,startClientX:t.clientX,startClientY:t.clientY,startPanX:panX,startPanY:panY};
      clearSelection(); e.preventDefault();
    }
  } else if(e.touches.length===2){
    pinch.active=true;
    const dx=e.touches[1].clientX-e.touches[0].clientX;
    const dy=e.touches[1].clientY-e.touches[0].clientY;
    pinch.startDist=Math.hypot(dx,dy); pinch.startScale=scale;
    pinch.cx=(e.touches[0].clientX+e.touches[1].clientX)/2;
    pinch.cy=(e.touches[0].clientY+e.touches[1].clientY)/2;
    touchPan.active=false; e.preventDefault();
  }
},{passive:false});
workspace.addEventListener('touchmove', e=>{
  if(pinch.active && e.touches.length>=2){
    const dx=e.touches[1].clientX-e.touches[0].clientX, dy=e.touches[1].clientY-e.touches[0].clientY;
    const dist=Math.hypot(dx,dy); let newScale=pinch.startScale*dist/pinch.startDist; newScale=Math.max(.25,Math.min(3,newScale));
    const rect=canvas.getBoundingClientRect();
    const fx=(pinch.cx-rect.left-panX)/scale, fy=(pinch.cy-rect.top-panY)/scale;
    panX=pinch.cx-rect.left-fx*newScale; panY=pinch.cy-rect.top-fy*newScale; scale=newScale;
    updateTransform(); updateConnections(); e.preventDefault(); return;
  }
  if(!touchPan.active) return;
  for(const t of e.touches){
    if(t.identifier===touchPan.id){
      panX=touchPan.startPanX+(t.clientX-touchPan.startClientX);
      panY=touchPan.startPanY+(t.clientY-touchPan.startClientY);
      updateTransform(); updateConnections(); e.preventDefault(); return;
    }
  }
},{passive:false});
workspace.addEventListener('touchend', e=>{
  if(pinch.active && e.touches.length<2) pinch.active=false;
  if(!touchPan.active) return;
  let still=false; for(const t of e.touches){ if(t.identifier===touchPan.id) still=true; }
  if(!still) touchPan.active=false;
});

/* DnD (PC) + sidebar click (PC) */
components.forEach(comp=>{
  comp.addEventListener("dragstart", e=>{
    e.dataTransfer.setData("application/x-simupasir", comp.dataset.type);
    e.dataTransfer.setData("text/plain", comp.dataset.type);
    e.dataTransfer.effectAllowed='copy';
  });
  comp.addEventListener("click", ()=>{ currentToPlace = comp.dataset.type; components.forEach(c=>c.classList.remove('selected')); comp.classList.add('selected'); });
});
canvas.addEventListener("dragover", e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
canvas.addEventListener("drop", e=>{
  e.preventDefault(); if(simulation) return;
  const type=e.dataTransfer.getData("application/x-simupasir")||e.dataTransfer.getData("text/plain");
  if(!type) return; const pos=clientToWorkspace(e.clientX,e.clientY); createNode(type,pos.x,pos.y);
});

/* Paleta (m√≥vil) */
const fab = document.getElementById('fabPalette');
const modal = document.getElementById('paletteModal');
const grid = document.getElementById('paletteGrid');
const closePalette = document.getElementById('closePalette');
const PALETTE_TYPES = ['input','output','M','and','or','not','nand','nor','xor','xnor','sr'];
function openPalette(){
  grid.innerHTML=''; PALETTE_TYPES.forEach(t=>{ const b=document.createElement('button'); b.className='pick'; b.textContent=t.toUpperCase(); b.onclick=()=>{ currentToPlace=t; closePaletteModal(); }; grid.appendChild(b); });
  modal.style.display='block'; modal.setAttribute('aria-hidden','false');
}
function closePaletteModal(){ modal.style.display='none'; modal.setAttribute('aria-hidden','true'); }
fab.addEventListener('click', openPalette);
closePalette.addEventListener('click', closePaletteModal);
modal.addEventListener('click', (e)=>{ if(e.target===modal) closePaletteModal(); });

/* Tap para colocar o deseleccionar */
canvas.addEventListener('click', e=>{
  if(e.target===workspace || e.target===wiresSVG){
    if(currentToPlace){
      const pos=clientToWorkspace(e.clientX,e.clientY); createNode(currentToPlace,pos.x,pos.y);
    }else{
      clearSelection();
    }
  }
});

/* Selecci√≥n general */
function selectNode(node){ if(simulation) return; clearSelection(); selectedNode=node; node.el.classList.add('selected'); }
function selectConnection(conn){ if(simulation) return; clearSelection(); selectedConn=conn; conn.selected=true; conn.path?.classList.add('selected'); renderConnection(conn); }
function selectTag(tag){ if(selectedTag===tag) return; selectedTag?.classList.remove('selected'); selectedTag=tag; tag.classList.add('selected'); if(selectedConn){ selectedConn.path?.classList.remove('selected'); selectedConn.selected=false; selectedConn=null; } }
function clearSelection(){
  if(selectedNode){ selectedNode.el.classList.remove('selected'); selectedNode=null; }
  if(selectedConn){ selectedConn.path?.classList.remove('selected'); selectedConn.selected=false; selectedConn=null; }
  if(selectedTag){ selectedTag.classList.remove('selected'); selectedTag=null; }
  if(selectedBranch){ selectedBranch=null; }
  if(selectedPinEl){ selectedPinEl.classList.remove('pin-selected'); selectedPinEl=null; }
  pendingOutput=null; removeGhost(); hideWireMenu();
  if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; }
  connections.forEach(c=>{ (c.handles||[]).forEach(h=>h.remove()); c.handles=[]; });
}

/* Crear bloque */
function createNode(type,x,y){
  const div=document.createElement('div'); div.className='node'; div.style.left=x+'px'; div.style.top=y+'px';

  let display = logoLabelForType(type);
  if(type==='input')  display = `I${++inputCount}`;
  else if(type==='output') display = `Q${++outputCount}`;
  else if(type==='M')      display = `M${++memoryCount}`;

  /* Badge B001... (no para I/Q/M) */
  let blockCode=null;
  if(type!=='input' && type!=='output' && type!=='M'){
    blockCode = 'B'+zpad(++blockCodeCount);
    const badge=document.createElement('div'); badge.className='badge'; badge.textContent=blockCode; div.appendChild(badge);
  }

  const lbl=document.createElement('div'); lbl.className='label'; lbl.textContent=display; div.appendChild(lbl);
  const qind=document.createElement('div'); qind.className='q-indicator off'; div.appendChild(qind);

  const output=document.createElement('div'); output.className='terminal output';
  if(type==='not' || type==='nand' || type==='nor'){ output.classList.add('out-round'); }
  div.appendChild(output);

  const inputs=[];
  if(type==='input'){ div.style.background='#ffe4b5'; }
  else if(type==='output'||type==='M'){ const inp=document.createElement('div'); inp.className='terminal input'; inp.style.top='50%'; div.appendChild(inp); inputs.push(inp); }
  else if(type==='not'){ const inp=document.createElement('div'); inp.className='terminal input'; inp.style.top='50%'; div.appendChild(inp); inputs.push(inp); }
  else if(type==='sr'){
    const inS=document.createElement('div'); inS.className='terminal input'; inS.style.top='28%';
    const labelS=document.createElement('div'); labelS.className='term-label'; labelS.style.top='24%'; labelS.textContent='S';
    const inR=document.createElement('div'); inR.className='terminal input'; inR.style.top='72%';
    const labelR=document.createElement('div'); labelR.className='term-label'; labelR.style.top='68%'; labelR.textContent='R';
    div.appendChild(inS); div.appendChild(labelS); div.appendChild(inR); div.appendChild(labelR);
    inputs.push(inS); inputs.push(inR);
  }else{
    const nInputs=4;
    for(let i=0;i<nInputs;i++){
      const inp=document.createElement('div'); inp.className='terminal input';
      inp.style.top = `${(i+1)*100/(nInputs+1)}%`;
      div.appendChild(inp); inputs.push(inp);
    }
  }

  workspace.appendChild(div);

  const node={ el:div, type, name:display, code:blockCode, inputs, output, value:0, nextValue:0, qIndicator:qind, invalid:false };
  if(type==='sr') node.q=0;
  nodes.push(node);

  if(node.output){ node.output.style.top='50%'; node.output.style.transform='translateY(-50%)'; }

  div.addEventListener('click', e=>{ if(e.target.classList.contains('terminal')) return; if(simulation) return; selectNode(node); });
  if(type==='input'){
    div.addEventListener('click', e=>{ if(e.target.classList.contains('terminal')) return; if(!simulation) return; div.classList.toggle('active'); scanLogic(); });
  }

  dragMove(div,node);
  enableConnections(node);
  div.addEventListener('contextmenu', e=>{ e.preventDefault(); if(!simulation) removeNode(node); });

  updateConnections();
}

/* Mover bloque (requiere seleccionado) */
function dragMove(el,node){
  let sx,sy,ix,iy,dragging=false;
  el.addEventListener('mousedown', e=>{
    if(e.target.classList.contains('terminal')) return;
    if(simulation) return;
    if(selectedNode!==node) return;
    e.preventDefault(); sx=e.clientX; sy=e.clientY; ix=parseFloat(el.style.left); iy=parseFloat(el.style.top);
    dragging=true; document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
  function onMove(e){ if(!dragging) return; el.style.left=ix+(e.clientX-sx)/scale+'px'; el.style.top=iy+(e.clientY-sy)/scale+'px'; updateConnections(); }
  function onUp(){ dragging=false; document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); }
  el.addEventListener('touchstart', e=>{
    if(simulation) return; if(selectedNode!==node) return;
    const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; ix=parseFloat(el.style.left); iy=parseFloat(el.style.top);
    dragging=true; document.addEventListener('touchmove',onTouchMove,{passive:false}); document.addEventListener('touchend',onTouchEnd);
    e.stopPropagation(); e.preventDefault();
  },{passive:false});
  function onTouchMove(e){ if(!dragging) return; const t=e.changedTouches[0]; el.style.left=ix+(t.clientX-sx)/scale+'px'; el.style.top=iy+(t.clientY-sy)/scale+'px'; updateConnections(); e.preventDefault(); }
  function onTouchEnd(){ dragging=false; document.removeEventListener('touchmove',onTouchMove); document.removeEventListener('touchend',onTouchEnd); }
}

/* Conexiones y pines */
function enableConnections(node){
  const handler = el=>{
    if(simulation) return;
    if(el.classList.contains('output')){
      selectedPinEl?.classList.remove('pin-selected');
      selectedPinEl=el; el.classList.add('pin-selected');
      pendingOutput=el; showGhost(el); return;
    }
    if(el.classList.contains('input')){
      el.classList.add('pin-target'); setTimeout(()=>el.classList.remove('pin-target'),300);
      if(!pendingOutput) return;
      if(pendingOutput===el){ removeGhost(); selectedPinEl?.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null; return; }
      createConnection(pendingOutput, el);
      removeGhost(); selectedPinEl?.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null;
    }
  };
  node.output && node.output.addEventListener('click', ()=>handler(node.output));
  node.inputs.forEach(inp=>inp.addEventListener('click', ()=>handler(inp)));
}

/* Ghost al crear conexi√≥n */
function showGhost(fromTerm){
  removeGhost();
  const s=terminalEdge(fromTerm);
  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("class","wire-path ghost"); updateGhostPath(path,s.x,s.y,s.x,s.y);
  wiresSVG.appendChild(path); pendingGhost=path;
  workspace.addEventListener('mousemove',trackGhost);
  workspace.addEventListener('touchmove',trackGhostTouch,{passive:false});
}
function removeGhost(){
  pendingGhost?.remove(); pendingGhost=null;
  workspace.removeEventListener('mousemove',trackGhost);
  workspace.removeEventListener('touchmove',trackGhostTouch);
}
function trackGhost(e){ if(!pendingGhost||!pendingOutput) return; const p=clientToWorkspace(e.clientX,e.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); }
function trackGhostTouch(e){ if(!pendingGhost||!pendingOutput) return; const t=e.touches[0]; const p=clientToWorkspace(t.clientX,t.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); e.preventDefault(); }
function updateGhostPath(path,sx,sy,ex,ey){ const midX=(sx+ex)/2; path.setAttribute('d',`M${sx},${sy} L${midX},${sy} L${midX},${ey} L${ex},${ey}`); }

/* ===== Helpers etiquetas ===== */
function getSourceName(conn){
  const srcNode = nodes.find(n=>n.output===conn.from);
  if(!srcNode) return '??';
  if(srcNode.type==='input'||srcNode.type==='output'||srcNode.type==='M') return srcNode.name;
  return srcNode.code || 'B???';
}
function getDestNameWithPin(conn){
  const dstNode = nodes.find(n=>n.inputs.includes(conn.to));
  if(!dstNode) return '??';
  const pinIndex = 1 + dstNode.inputs.indexOf(conn.to);
  if(dstNode.type==='input'||dstNode.type==='output'||dstNode.type==='M') return `${dstNode.name}/${pinIndex}`;
  return `${dstNode.code || 'B???'}/${pinIndex}`;
}

/* ===== Hubs (juntas) de salida ===== */
function ensureHub(pinEl){
  let hub = outputHubs.get(pinEl);
  if(hub) return hub;

  const p = terminalEdge(pinEl);
  const x = p.x + 18, y = p.y;
  const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
  dot.setAttribute('cx', x); dot.setAttribute('cy', y); dot.setAttribute('r', 6);
  dot.setAttribute('class','hub-dot');
  const hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
  hit.setAttribute('cx', x); hit.setAttribute('cy', y); hit.setAttribute('r', 18);
  hit.setAttribute('class','hub-hit');

  const stem = document.createElementNS("http://www.w3.org/2000/svg","path");
  stem.setAttribute('class','wire-path');

  wiresSVG.appendChild(stem);
  wiresSVG.appendChild(hit);
  wiresSVG.appendChild(dot);

  const hubObj = { x, y, dot, hit, stemPath:stem, pin:pinEl, branches:new Set() };
  outputHubs.set(pinEl, hubObj);

  const startDrag = (ev)=>{
    ev.stopPropagation();
    const start = (ev.touches? ev.touches[0]:ev);
    const s = clientToWorkspace(start.clientX, start.clientY);
    const ox = hubObj.x, oy = hubObj.y;
    const move = (ev2)=>{
      const cur = (ev2.touches? ev2.touches[0]:ev2);
      const wp = clientToWorkspace(cur.clientX, cur.clientY);
      hubObj.x = ox + (wp.x - s.x);
      hubObj.y = oy + (wp.y - s.y);
      renderHub(hubObj);
    };
    const end = ()=>{
      document.removeEventListener('mousemove',move);
      document.removeEventListener('mouseup',end);
      document.removeEventListener('touchmove',move);
      document.removeEventListener('touchend',end);
    };
    document.addEventListener('mousemove',move);
    document.addEventListener('mouseup',end);
    document.addEventListener('touchmove',move,{passive:false});
    document.addEventListener('touchend',end,{passive:true});
  };
  dot.addEventListener('mousedown',startDrag);
  dot.addEventListener('touchstart',startDrag,{passive:false});
  hit.addEventListener('mousedown',startDrag);
  hit.addEventListener('touchstart',startDrag,{passive:false});

  renderHub(hubObj);
  return hubObj;
}
function renderHub(hub){
  hub.dot.setAttribute('cx', hub.x); hub.dot.setAttribute('cy', hub.y);
  hub.hit.setAttribute('cx', hub.x); hub.hit.setAttribute('cy', hub.y);

  const e = terminalEdge(hub.pin);
  const d = `M${e.x},${e.y} L${hub.x-10},${e.y} L${hub.x-10},${hub.y} L${hub.x},${hub.y}`;
  hub.stemPath.setAttribute('d', d);

  for (const br of hub.branches) renderBranch(br);
}

/* ===== Estructuras de rama/etiqueta ===== */
function createTagEl(text, isSource){
  const tag = document.createElement('div');
  tag.className = 'conn-tag' + (isSource ? ' conn-tag-src' : '');
  tag.textContent = text;
  workspace.appendChild(tag);
  return tag;
}

function attachDragToTag(branch){
  const tag = branch.tagEl;
  let dragging=false, sx=0, sy=0, ox=0, oy=0;
  const start=(ev)=>{
    ev.stopPropagation();
    dragging=true;
    const pt=(ev.touches? ev.touches[0]:ev);
    const wp=clientToWorkspace(pt.clientX, pt.clientY);
    sx=wp.x; sy=wp.y; ox=branch.tx; oy=branch.ty;
    document.addEventListener('mousemove',move);
    document.addEventListener('mouseup',end);
    document.addEventListener('touchmove',move,{passive:false});
    document.addEventListener('touchend',end,{passive:true});
  };
  const move=(ev)=>{
    if(!dragging) return;
    const pt=(ev.touches? ev.touches[0]:ev);
    const wp=clientToWorkspace(pt.clientX, pt.clientY);
    branch.tx = ox + (wp.x - sx);
    branch.ty = oy + (wp.y - sy);
    renderBranch(branch);
    ev.preventDefault?.();
  };
  const end=()=>{
    dragging=false;
    document.removeEventListener('mousemove',move);
    document.removeEventListener('mouseup',end);
    document.removeEventListener('touchmove',move);
    document.removeEventListener('touchend',end);
  };
  tag.addEventListener('mousedown', start);
  tag.addEventListener('touchstart', start, {passive:false});
  tag.addEventListener('click', (e)=>{ e.stopPropagation(); selectTag(tag); });
}

/* Crea una rama desde HUB o desde PIN (entrada) hacia la etiqueta */
function createBranch({fromHub, hub, fromPin, pinEl, text}){
  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute('class','wire-path');
  const hit  = document.createElementNS("http://www.w3.org/2000/svg","path");
  hit.setAttribute('class','wire-hit');

  wiresSVG.appendChild(hit);
  wiresSVG.appendChild(path);

  const tag = createTagEl(text, !!fromHub);

  // posici√≥n inicial de la etiqueta
  let start;
  if(fromHub) start = {x:hub.x, y:hub.y};
  else { const e=terminalEdge(pinEl); start = {x:e.x-40, y:e.y}; }

  const branch = {
    fromHub, hub, fromPin, pinEl,
    path, hit, tagEl:tag,
    bends:[],
    tx: start.x + (fromHub? 60 : -60),
    ty: start.y - 20
  };

  // interacci√≥n: selecci√≥n y long-press para agregar nodos
  const onLP = (ev)=>{
    ev.stopPropagation();
    let cancelled=false;
    const cancel=()=>{ cancelled=true; if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; } document.removeEventListener('mouseup',cancel); document.removeEventListener('touchend',cancel); };
    document.addEventListener('mouseup',cancel,{once:true});
    document.addEventListener('touchend',cancel,{once:true,passive:true});
    longPressTimer=setTimeout(()=>{
      if(cancelled) return;
      const pt=(ev.type==='mousedown')?ev:(ev.touches?.[0] ?? ev);
      const wp=clientToWorkspace(pt.clientX, pt.clientY);
      branch.bends.push({x:wp.x, y:wp.y});
      renderBranch(branch);
    },400);
  };
  path.addEventListener('mousedown', onLP);
  path.addEventListener('touchstart', onLP, {passive:false});
  hit .addEventListener('mousedown', onLP);
  hit .addEventListener('touchstart', onLP, {passive:false});

  attachDragToTag(branch);
  renderBranch(branch);

  // selecci√≥n de rama
  const onSel=(e)=>{ e.stopPropagation(); selectedBranch=branch; selectTag(tag); };
  hit.addEventListener('click', onSel);
  hit.addEventListener('touchstart', onSel, {passive:true});

  return branch;
}

/* Render de una rama (desde hub o pin) hasta la etiqueta */
function renderBranch(branch){
  const sx = branch.fromHub ? branch.hub.x : terminalEdge(branch.pinEl).x;
  const sy = branch.fromHub ? branch.hub.y : terminalEdge(branch.pinEl).y;
  const ex = branch.tx, ey = branch.ty;

  let d='';
  if(branch.bends.length===0){
    const midX=(sx+ex)/2; d=`M${sx},${sy} L${midX},${sy} L${midX},${ey} L${ex},${ey}`;
  }else{
    const pts=[{x:sx,y:sy}].concat(branch.bends).concat([{x:ex,y:ey}]);
    d=`M${pts[0].x},${pts[0].y} `; for(let i=1;i<pts.length;i++){ const prev=pts[i-1], next=pts[i]; d+=`L${next.x},${prev.y} L${next.x},${next.y} `; }
  }
  branch.path.setAttribute('d', d);
  branch.hit.setAttribute('d', d);

  branch.tagEl.style.left = ex + 'px';
  branch.tagEl.style.top  = ey + 'px';
}

/* Convertir un cable a etiquetas + hub/ramas en salida y cable en entrada */
function convertWireToLabel(conn){
  conn.path && conn.path.remove(); conn.path=null;
  conn.hit && conn.hit.remove(); conn.hit=null;
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];

  const srcName = getDestNameWithPin(conn);
  const inName  = getSourceName(conn);

  const hub = ensureHub(conn.from);
  const srcBranch = createBranch({fromHub:true, hub, text:srcName});
  hub.branches.add(srcBranch);
  conn.srcBranch = srcBranch;

  const dstBranch = createBranch({fromHub:false, pinEl:conn.to, text:inName});
  conn.dstBranch = dstBranch;

  conn.mode = 'label';
  renderConnection(conn);
}

/* Crear conexi√≥n normal */
function createConnection(fromTerm,toTerm){
  if(simulation) return;
  if(connections.find(c => c.from===fromTerm && c.to===toTerm)) return;
  const conn={ from:fromTerm, to:toTerm, path:null, hit:null, bends:[], handles:[], selected:false, mode:'wire',
               srcBranch:null, dstBranch:null };
  connections.push(conn); renderConnection(conn);
}

/* Men√∫ contextual en cables (solo modo wire) */
const wireMenu = document.getElementById('wireMenu');
const menuAddNode = document.getElementById('menuAddNode');
const menuMakeLabel = document.getElementById('menuMakeLabel');
let menuContext = { conn:null, clientX:0, clientY:0 };

function showWireMenu(conn, clientX, clientY){
  menuContext = { conn, clientX, clientY };
  wireMenu.style.display='block';
  const vw = window.innerWidth, vh = window.innerHeight;
  const menuW = 260, menuH = 90;
  let x = clientX, y = clientY;
  if(x + menuW > vw) x = vw - menuW - 8;
  if(y + menuH > vh) y = vh - menuH - 8;
  wireMenu.style.left = x + 'px';
  wireMenu.style.top  = y + 'px';
}
function hideWireMenu(){ wireMenu.style.display='none'; }
menuAddNode.addEventListener('click', ()=>{
  const {conn, clientX, clientY} = menuContext;
  hideWireMenu();
  if(!conn) return;
  const pos=clientToWorkspace(clientX, clientY);
  conn.bends.push({x:pos.x,y:pos.y}); selectConnection(conn); renderConnection(conn);
});
menuMakeLabel.addEventListener('click', ()=>{
  const {conn} = menuContext;
  hideWireMenu();
  if(!conn) return;
  convertWireToLabel(conn);
});
document.addEventListener('click', (e)=>{ if(e.target!==wireMenu && !wireMenu.contains(e.target)) hideWireMenu(); });

/* Render conexi√≥n (wire o label) + estilos de se√±al */
function renderConnection(conn){
  if(conn.mode==='label'){
    // pintar branches
    if(conn.srcBranch) renderBranch(conn.srcBranch);
    if(conn.dstBranch) renderBranch(conn.dstBranch);
    const hub = outputHubs.get(conn.from);
    hub && renderHub(hub);

    // actualizar estilos de se√±al para branches + etiquetas + pin de entrada
    const srcVal=getSourceNodeValue(conn);
    if(conn.srcBranch){
      conn.srcBranch.path.classList.toggle('signal', srcVal===1);
      conn.srcBranch.tagEl.classList.toggle('signal', srcVal===1);
    }
    if(conn.dstBranch){
      conn.dstBranch.path.classList.toggle('signal', srcVal===1);
      conn.dstBranch.tagEl.classList.toggle('signal', srcVal===1);
    }
    // pin destino (entrada) con se√±al
    conn.to.classList.toggle('signal-on', srcVal===1);
    updatePinsVisual(conn, srcVal);
    return;
  }

  // modo wire
  conn.path?.remove(); conn.hit?.remove();
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];

  const s=terminalEdge(conn.from), e=terminalEdge(conn.to);
  let d='';
  if(conn.bends.length===0){
    const midX=(s.x+e.x)/2; d=`M${s.x},${s.y} L${midX},${s.y} L${midX},${e.y} L${e.x},${e.y}`;
  }else{
    const pts=[{x:s.x,y:s.y}].concat(conn.bends).concat([{x:e.x,y:e.y}]);
    d=`M${pts[0].x},${pts[0].y} `; for(let i=1;i<pts.length;i++){ const prev=pts[i-1], next=pts[i]; d+=`L${next.x},${prev.y} L${next.x},${next.y} `; }
  }

  const hit=document.createElementNS("http://www.w3.org/2000/svg","path");
  hit.setAttribute("d",d); hit.setAttribute("class","wire-hit");

  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d",d); path.setAttribute("class","wire-path");
  if(conn.selected) path.classList.add('selected');

  const srcVal=getSourceNodeValue(conn);
  path.classList.toggle('signal', srcVal===1);
  // pin destino con se√±al
  conn.to.classList.toggle('signal-on', srcVal===1);

  const onSelect=(ev)=>{ ev.stopPropagation(); if(simulation) return; selectConnection(conn); };
  hit.addEventListener('click',onSelect);
  hit.addEventListener('touchstart',onSelect,{passive:true});
  hit.addEventListener('contextmenu',(ev)=>{ ev.preventDefault(); if(simulation) return; showWireMenu(conn, ev.clientX, ev.clientY); });

  function onPathDown(ev){
    if(simulation) return;
    if(ev.type==='mousedown' && ev.button!==0) return;
    ev.stopPropagation();
    let cancelled=false;
    const cancel=()=>{ cancelled=true; if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; } document.removeEventListener('mouseup',cancel); document.removeEventListener('touchend',cancel); };
    document.addEventListener('mouseup',cancel,{once:true});
    document.addEventListener('touchend',cancel,{once:true,passive:true});
    longPressTimer=setTimeout(()=>{
      if(cancelled) return;
      const clientX=(ev.type==='mousedown')?ev.clientX:(ev.touches?.[0]?.clientX ?? ev.clientX);
      const clientY=(ev.type==='mousedown')?ev.clientY:(ev.touches?.[0]?.clientY ?? ev.clientY);
      showWireMenu(conn, clientX, clientY);
    },400);
  }
  path.addEventListener('mousedown',onPathDown);
  path.addEventListener('touchstart',onPathDown,{passive:false});
  hit .addEventListener('mousedown',onPathDown);
  hit .addEventListener('touchstart',onPathDown,{passive:false});

  wiresSVG.appendChild(hit);
  wiresSVG.appendChild(path);
  conn.hit=hit; conn.path=path;

  // Handles si est√° seleccionado
  if(conn.selected && !simulation){
    conn.handles=[];
    conn.bends.forEach((b,idx)=>{
      const g=document.createElementNS("http://www.w3.org/2000/svg","g");
      const hitC=document.createElementNS("http://www.w3.org/2000/svg","circle");
      hitC.setAttribute('cx',b.x); hitC.setAttribute('cy',b.y); hitC.setAttribute('r',24); hitC.setAttribute('class','bend-hit');
      const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute('cx',b.x); c.setAttribute('cy',b.y); c.setAttribute('r',11); c.setAttribute('class','bend-handle');
      g.appendChild(hitC); g.appendChild(c); wiresSVG.appendChild(g);
      conn.handles.push(c);
      const start=(ev)=>{ if(simulation) return; ev.stopPropagation(); startDraggingHandle(conn, idx); };
      c.addEventListener('mousedown',start); c.addEventListener('touchstart',start,{passive:true});
      hitC.addEventListener('mousedown',start); hitC.addEventListener('touchstart',start,{passive:true});
    });
  }

  updatePinsVisual(conn, srcVal);
}

/* Bend dragging */
function startDraggingHandle(conn,index){
  if(conn.handles && conn.handles[index]) conn.handles[index].classList.add('dragging');
  draggingBend={conn,index};
  document.addEventListener('mousemove',onBendMove);
  document.addEventListener('mouseup',stopDraggingHandle);
  document.addEventListener('touchmove',onBendMoveTouch,{passive:false});
  document.addEventListener('touchend',stopDraggingHandle,{passive:true});
}
function stopDraggingHandle(){
  if(!draggingBend) return;
  const {conn,index}=draggingBend;
  if(conn.handles && conn.handles[index]) conn.handles[index].classList.remove('dragging');
  draggingBend=null;
  document.removeEventListener('mousemove',onBendMove);
  document.removeEventListener('mouseup',stopDraggingHandle);
  document.removeEventListener('touchmove',onBendMoveTouch);
  document.removeEventListener('touchend',stopDraggingHandle);
}
function onBendMove(ev){
  if(!draggingBend) return;
  const pos=clientToWorkspace(ev.clientX,ev.clientY);
  const {conn,index}=draggingBend;
  conn.bends[index].x=pos.x; conn.bends[index].y=pos.y;
  renderConnection(conn);
}
function onBendMoveTouch(ev){
  if(!draggingBend) return; ev.preventDefault();
  const t=ev.touches[0]; const pos=clientToWorkspace(t.clientX,t.clientY);
  const {conn,index}=draggingBend;
  conn.bends[index].x=pos.x; conn.bends[index].y=pos.y;
  renderConnection(conn);
}

/* Utilidades pins */
function updatePinsVisual(conn, srcVal){
  try{ conn.from.classList.toggle('signal-on', srcVal===1); }catch(e){}
  const srcNode=nodes.find(n=>n.output===conn.from);
  srcNode && srcNode.qIndicator && srcNode.qIndicator.classList.toggle('on', srcVal===1);
}
function getSourceNodeValue(conn){ const n=nodes.find(nn=>nn.output===conn.from); return n? n.value:0; }
function updateConnections(){ connections.forEach(c=>renderConnection(c)); }

/* Eliminar bloque + cables asociados y limpiar hubs */
function removeNode(node){
  if(simulation) return;

  if(selectedPinEl && (selectedPinEl===node.output || node.inputs.includes(selectedPinEl))){
    selectedPinEl.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null; removeGhost();
  }
  const toRemove = connections.filter(c=> c.from===node.output || node.inputs.includes(c.to) );
  toRemove.forEach(removeConnection);

  if(node.output){
    const hub = outputHubs.get(node.output);
    if(hub){
      for(const br of hub.branches){
        br.tagEl.remove(); br.path.remove(); br.hit.remove();
      }
      hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
      outputHubs.delete(node.output);
    }
  }

  node.el.remove();
  nodes = nodes.filter(n=>n!==node);

  clearSelection();
  updateConnections();
}

/* Eliminar conexi√≥n */
function removeConnection(conn){
  if(!conn) return;
  conn.path && conn.path.remove(); conn.hit && conn.hit.remove();
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];

  if(conn.srcBranch){
    const hub = conn.srcBranch.hub;
    if(hub){ hub.branches.delete(conn.srcBranch); }
    conn.srcBranch.tagEl.remove(); conn.srcBranch.path.remove(); conn.srcBranch.hit.remove();
    conn.srcBranch=null;
    if(hub && hub.branches.size===0){
      hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
      outputHubs.delete(hub.pin);
    }
  }
  if(conn.dstBranch){
    conn.dstBranch.tagEl.remove(); conn.dstBranch.path.remove(); conn.dstBranch.hit.remove();
    conn.dstBranch=null;
  }

  const i=connections.indexOf(conn); if(i>=0) connections.splice(i,1);
  if(selectedConn===conn) selectedConn=null;
  if(selectedTag && (selectedTag===conn.tagSrcEl || selectedTag===conn.tagDstEl)){ selectedTag.classList.remove('selected'); selectedTag=null; }
}

/* L√≥gica */
function evaluateGate(type,inputs){
  if(inputs.length===0) return 0;
  switch(type){
    case 'and': return inputs.every(v=>v===1)?1:0;
    case 'or':  return inputs.some(v=>v===1)?1:0;
    case 'not': return inputs[0]?0:1;
    case 'nand':return inputs.every(v=>v===1)?0:1;
    case 'nor': return inputs.some(v=>v===1)?0:1;
    case 'xor': return inputs.reduce((a,b)=>a^b,0);
    case 'xnor':return evaluateGate('xor',inputs)?0:1;
    default: return inputs[0]||0;
  }
}
function scanLogic(){
  nodes.forEach(n=>{ if(n.type==='input') n.value = n.el.classList.contains('active')?1:0; n.invalid=false; });

  nodes.forEach(node=>{
    node.nextValue=node.value; if(node.type==='input') return;
    const inVals=connections.filter(c=>node.inputs.includes(c.to)).map(c=>{
      const s=nodes.find(n=>n.output===c.from); return s ? s.value : 0;
    });
    if(inVals.length===0){
      if(node.type==='output' || node.type==='M') node.nextValue=0;
      else if(node.type==='sr') node.nextValue=node.q||0;
      else node.nextValue=0; return;
    }
    if(node.type==='output' || node.type==='M') node.nextValue=inVals[0]?1:0;
    else if(node.type==='sr'){
      const S=inVals[0]?1:0, R=inVals[1]?1:0;
      if(S===1 && R===0){ node.q=1; node.nextValue=1; }
      else if(S===0 && R===1){ node.q=0; node.nextValue=0; }
      else node.nextValue=node.q||0;
    }else node.nextValue=evaluateGate(node.type,inVals)?1:0;
  });

  nodes.forEach(n=>{ n.value=n.nextValue; if(n.type==='sr') n.q=n.nextValue; });

  nodes.forEach(n=>{
    const active = n.value===1;
    if(n.type==='input' || n.type==='output' || n.type==='M'){
      n.el.classList.toggle('active', active);
      n.output && n.output.classList.toggle('signal-on', active);
    }else{
      n.el.classList.remove('active');
    }
    // borde del bloque activo:
    n.el.classList.toggle('active-border', active);
    n.qIndicator && n.qIndicator.classList.toggle('on', active);
    n.el.classList.toggle('error', !!n.invalid);
  });

  updateConnections();
}

/* Botones */
const btnSim = document.getElementById('simulate');
document.getElementById('simulate').addEventListener('click', ()=>{
  if(simulation) return;
  clearSelection(); simulation=true; btnSim.classList.add('sim-on');
  scanLogic(); simTimer=setInterval(scanLogic,SCAN_MS);
});
document.getElementById('stop').addEventListener('click', ()=>{
  if(simTimer){ clearInterval(simTimer); simTimer=null; }
  simulation=false; btnSim.classList.remove('sim-on');
  nodes.forEach(n=>{
    n.value=0;
    if(n.type==='input'||n.type==='output'||n.type==='M') n.el.classList.remove('active');
    n.qIndicator && n.qIndicator.classList.remove('on');
    n.invalid=false; n.output && n.output.classList.remove('signal-on');
    n.el.classList.remove('active-border');
  });
  updateConnections();
});
document.getElementById('deleteBtn').addEventListener('click', ()=>{
  if(simulation) return;
  if(selectedNode){ removeNode(selectedNode); return; }
  if(selectedConn){ removeConnection(selectedConn); updateConnections(); return; }
  if(selectedTag && selectedBranch){
    const conn = connections.find(c=> c.srcBranch===selectedBranch || c.dstBranch===selectedBranch );
    if(conn){
      if(conn.srcBranch===selectedBranch){
        const hub = selectedBranch.hub;
        hub && hub.branches.delete(selectedBranch);
        selectedBranch.tagEl.remove(); selectedBranch.path.remove(); selectedBranch.hit.remove();
        conn.srcBranch=null;
        if(hub && hub.branches.size===0){
          hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
          outputHubs.delete(hub.pin);
        }
      }else if(conn.dstBranch===selectedBranch){
        selectedBranch.tagEl.remove(); selectedBranch.path.remove(); selectedBranch.hit.remove();
        conn.dstBranch=null;
      }
      if(!conn.srcBranch && !conn.dstBranch){
        const i=connections.indexOf(conn); if(i>=0) connections.splice(i,1);
      }
      updateConnections();
    }
    selectedBranch=null; selectedTag=null;
    return;
  }
  if(selectedTag){
    for(const conn of connections){
      if(conn.srcBranch && conn.srcBranch.tagEl===selectedTag){ selectedBranch=conn.srcBranch; break; }
      if(conn.dstBranch && conn.dstBranch.tagEl===selectedTag){ selectedBranch=conn.dstBranch; break; }
    }
    document.getElementById('deleteBtn').click();
  }
});

/* Click en tag para fijar selectedBranch */
workspace.addEventListener('click', (e)=>{
  if(e.target.classList && e.target.classList.contains('conn-tag')){
    for(const conn of connections){
      if(conn.srcBranch && conn.srcBranch.tagEl===e.target){ selectedBranch=conn.srcBranch; break; }
      if(conn.dstBranch && conn.dstBranch.tagEl===e.target){ selectedBranch=conn.dstBranch; break; }
    }
  }
});

/* Teclas */
document.getElementById('zoomIn').addEventListener('click', ()=>setZoom(scale+0.12));
document.getElementById('zoomOut').addEventListener('click', ()=>setZoom(scale-0.12));

document.addEventListener('keydown', (e)=>{
  if(e.key==='Delete' || e.key==='Backspace'){
    if(simulation) return;
    document.getElementById('deleteBtn').click();
  }
  if(e.key==='Escape'){ clearSelection(); }
});

/* Redibuja en resize */
window.addEventListener('resize', updateConnections);

/* ===== Guardar / Importar ===== */
document.getElementById('toggleLib').addEventListener('click', ()=>{
  document.body.classList.toggle('hide-sidebar');
  document.getElementById('toggleLib').textContent = document.body.classList.contains('hide-sidebar') ? 'Mostrar biblioteca' : 'Ocultar biblioteca';
});

document.getElementById('btnSave').addEventListener('click', ()=>{
  const data = serializeProject();
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'circuito.simupasir.json';
  a.click();
  URL.revokeObjectURL(a.href);
});

document.getElementById('fileInput').addEventListener('change', async (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  try{
    const text = await file.text();
    const data = JSON.parse(text);
    loadProject(data);
  }catch(err){
    alert('Archivo inv√°lido');
    console.error(err);
  }finally{
    e.target.value='';
  }
});

// serializar nodos y conexiones
function serializeProject(){
  // asignar id a cada nodo
  const nodeIds = new Map();
  nodes.forEach((n,i)=> nodeIds.set(n, i));

  const nodesData = nodes.map(n=>({
    id: nodeIds.get(n),
    type: n.type,
    name: n.name,
    code: n.code || null,
    x: parseFloat(n.el.style.left)||0,
    y: parseFloat(n.el.style.top)||0
  }));

  const connsData = connections.map(c=>{
    const fromNode = nodes.find(n=>n.output===c.from);
    const toNode   = nodes.find(n=>n.inputs.includes(c.to));
    const toIndex  = toNode ? toNode.inputs.indexOf(c.to) : 0;
    const base = {
      fromNodeId: nodeIds.get(fromNode),
      toNodeId: nodeIds.get(toNode),
      toPinIndex: toIndex,
      mode: c.mode || 'wire',
      bends: (c.bends||[]).map(b=>({x:b.x,y:b.y}))
    };
    if(c.mode==='label'){
      const hub = outputHubs.get(c.from);
      base.hub = hub ? { x: hub.x, y: hub.y } : null;
      base.srcBranch = c.srcBranch ? {
        tx: c.srcBranch.tx, ty: c.srcBranch.ty,
        bends: (c.srcBranch.bends||[]).map(b=>({x:b.x,y:b.y})),
        text: c.srcBranch.tagEl.textContent
      } : null;
      base.dstBranch = c.dstBranch ? {
        tx: c.dstBranch.tx, ty: c.dstBranch.ty,
        bends: (c.dstBranch.bends||[]).map(b=>({x:b.x,y:b.y})),
        text: c.dstBranch.tagEl.textContent
      } : null;
    }
    return base;
  });

  return {
    meta:{ app:'SIMUPASIR', version:1 },
    view:{ panX, panY, scale },
    counters:{ inputCount, outputCount, memoryCount, blockCodeCount },
    nodes:nodesData,
    connections:connsData
  };
}

function clearProject(){
  // borrar conexiones y hubs
  connections.slice().forEach(removeConnection);
  // borrar nodos
  nodes.slice().forEach(n=>n.el.remove());
  nodes = [];
  // limpiar hubs expl√≠citos
  outputHubs.forEach((hub)=>{
    hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
  });
  outputHubs.clear();
  // reset selecci√≥n
  clearSelection();
}

function loadProject(data){
  if(!data || !Array.isArray(data.nodes)) return;
  clearProject();
  // restaurar contadores y vista
  inputCount = data.counters?.inputCount || 0;
  outputCount = data.counters?.outputCount || 0;
  memoryCount = data.counters?.memoryCount || 0;
  blockCodeCount = data.counters?.blockCodeCount || 0;
  panX = data.view?.panX ?? 0;
  panY = data.view?.panY ?? 0;
  scale = data.view?.scale ?? 1;
  updateTransform();

  // crear nodos
  const idToNode = new Map();
  data.nodes.forEach(nd=>{
    createNode(nd.type, nd.x, nd.y);
    const created = nodes[nodes.length-1];
    // forzamos etiqueta y c√≥digo si exist√≠an
    created.name = nd.name;
    if(created.type!=='input' && created.type!=='output' && created.type!=='M'){
      created.code = nd.code;
      const badge = created.el.querySelector('.badge');
      if(badge) badge.textContent = created.code || badge.textContent;
    }
    idToNode.set(nd.id, created);
  });

  // crear conexiones
  (data.connections||[]).forEach(cd=>{
    const fromNode = idToNode.get(cd.fromNodeId);
    const toNode   = idToNode.get(cd.toNodeId);
    if(!fromNode || !toNode) return;
    const toTerm = toNode.inputs[cd.toPinIndex] || toNode.inputs[0];
    const connEl = createConnection(fromNode.output, toTerm);
  });

  // aplicar bends y modo label
  (data.connections||[]).forEach((cd,idx)=>{
    const fromNode = idToNode.get(cd.fromNodeId);
    const toNode   = idToNode.get(cd.toNodeId);
    if(!fromNode || !toNode) return;
    const conn = connections.find(c=> c.from===fromNode.output && toNode.inputs.includes(c.to) && toNode.inputs.indexOf(c.to)===cd.toPinIndex);
    if(!conn) return;
    conn.bends = (cd.bends||[]).map(b=>({x:b.x,y:b.y}));
    if(cd.mode==='label'){
      convertWireToLabel(conn);
      if(cd.hub){
        const hub = outputHubs.get(conn.from);
        if(hub){ hub.x = cd.hub.x; hub.y = cd.hub.y; renderHub(hub); }
      }
      if(cd.srcBranch){
        conn.srcBranch.tx = cd.srcBranch.tx; conn.srcBranch.ty = cd.srcBranch.ty;
        conn.srcBranch.bends = (cd.srcBranch.bends||[]).map(b=>({x:b.x,y:b.y}));
        conn.srcBranch.tagEl.textContent = cd.srcBranch.text || conn.srcBranch.tagEl.textContent;
      }
      if(cd.dstBranch){
        conn.dstBranch.tx = cd.dstBranch.tx; conn.dstBranch.ty = cd.dstBranch.ty;
        conn.dstBranch.bends = (cd.dstBranch.bends||[]).map(b=>({x:b.x,y:b.y}));
        conn.dstBranch.tagEl.textContent = cd.dstBranch.text || conn.dstBranch.tagEl.textContent;
      }
    }
    renderConnection(conn);
  });

  updateConnections();
}

/* ===== Toggle biblioteca desde topbar ya est√° arriba ===== */

/* Init */
updateConnections();
console.log("SIMUPASIR: Guardar/Importar + men√∫ de biblioteca + se√±ales completas.");
</script>
</body>
</html>
