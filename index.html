<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SIMUPASIR ‚Äî TON / TOFF con tiempo visible</title>

<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#003366">
<link rel="icon" href="./icons/icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="./icons/icon-192.png">

<style>
  :root{
    --sidebar:#f3e5ab;
    --node:#fff8dc;
    --pin:#222;
    --wire:#000;
    --neon:#00ff66;
    --accent:#444;

    --pin-long:24px;
    --pin-hit-h:28px;
    --pin-visible-h:7px;
    --round-pin:28px;

    --workspace-size:5000px;
  }

  html,body{height:100%}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;display:flex;height:100vh;overflow:hidden;background:#fff}

  /* Canvas */
  #canvas{flex:1;background:#fff;position:relative;overflow:hidden;touch-action:none}
  #workspace{position:absolute;top:0;left:0;width:var(--workspace-size);height:var(--workspace-size);transform-origin:0 0;background:transparent}

  /* Bloques */
  .node{position:absolute;background:var(--node);border:3px solid var(--accent);border-radius:10px;width:150px;height:225px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:move;user-select:none;padding:8px;box-sizing:border-box;box-shadow:0 6px 0 rgba(0,0,0,.06);z-index:10;touch-action:none}
  .label{font-weight:900;margin-bottom:6px;pointer-events:none;color:#222;font-size:60px;line-height:1.05}
  .selected{box-shadow:0 10px 18px rgba(0,0,0,.12);border-color:#0058a3!important;transform:translateY(-2px)}
  .node.has-signal{border-color:var(--neon)!important; box-shadow:0 0 0 2px rgba(0,255,102,.25), 0 6px 0 rgba(0,0,0,.06)}

  /* Temporizadores: etiqueta m√°s peque√±a + readout */
  .node.timer .label{font-size:36px}
  .timer-readout{font-variant-numeric:tabular-nums; font-weight:800; margin-top:4px; padding:2px 8px; border:2px solid #003366; border-radius:10px; background:#fff; color:#003366; pointer-events:none}
  .node.has-signal .timer-readout{border-color:var(--neon); color:#000; background:var(--neon)}

  /* Badge B001‚Ä¶ */
  .badge{position:absolute;top:6px;left:6px;padding:4px 10px;border-radius:12px;border:2px solid #003366;background:#fff;color:#003366;font-weight:900;font-size:18px;line-height:1;pointer-events:none;user-select:none;box-shadow:0 2px 0 rgba(0,0,0,.06)}

  /* Pines */
  .terminal{position:absolute;cursor:pointer;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,.08);height:var(--pin-hit-h);background:transparent}
  .terminal::before{content:"";position:absolute;left:0;right:0;top:50%;transform:translateY(-50%);height:var(--pin-visible-h);border-radius:4px;background:var(--pin);display:block}
  .terminal.input{width:var(--pin-long);left:calc(-1 * var(--pin-long))}
  .terminal.output{width:var(--pin-long);right:calc(-1 * var(--pin-long));top:50%;transform:translateY(-50%)}
  .terminal.output.out-round{width:var(--round-pin);right:calc(-1 * var(--round-pin))}
  .terminal.output.out-round::before{width:var(--round-pin);height:var(--round-pin);border-radius:50%;background:#000;left:auto;right:0}
  .terminal.pin-selected::before{background:#0078d7!important;box-shadow:0 0 0 3px rgba(0,120,215,.25)}
  .terminal.pin-target{outline:2px solid #0078d7;outline-offset:2px}
  .terminal.signal-on::before{background:var(--neon)!important}
  .term-label{position:absolute;left:calc(-1 * var(--pin-long) - 36px);width:40px;text-align:right;font-size:12px;color:#222;user-select:none}

  /* Cables */
  #wires{position:absolute;top:0;left:0;width:var(--workspace-size);height:var(--workspace-size);pointer-events:auto;z-index:6}
  .wire-hit{fill:none;stroke:#000;stroke-width:40;stroke-opacity:0;vector-effect:non-scaling-stroke;pointer-events:stroke;stroke-linecap:round}
  .wire-path{fill:none;stroke:var(--wire);stroke-width:5;vector-effect:non-scaling-stroke;pointer-events:stroke}
  .wire-path.signal{stroke:var(--neon);stroke-width:6;filter:drop-shadow(0 0 8px rgba(0,255,102,.25))}
  .wire-path.selected{stroke:#0078d7;stroke-width:6}
  .wire-path.ghost{stroke-dasharray:6 6;opacity:.75}

  /* Hubs (juntas) */
  .hub-dot{fill:#000;stroke:#000;stroke-width:1.5;pointer-events:all;cursor:grab}
  .hub-hit{fill:#000;fill-opacity:0;pointer-events:all;cursor:grab}
  .hub-dot.signal{fill:var(--neon);stroke:var(--neon);filter:drop-shadow(0 0 8px rgba(0,255,102,.45))}

  /* Handles (nodos) */
  .bend-handle{fill:#fff;stroke:#0078d7;stroke-width:2.5px;r:11;cursor:grab;pointer-events:all}
  .bend-handle.dragging{fill:#e6f3ff}
  .bend-hit{fill:#000;fill-opacity:0;r:24;pointer-events:all}

  /* Controles (abajo, iguales) */
  #controls{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);background:var(--sidebar);padding:8px 12px;border-radius:10px;border:2px solid #bdb089;display:flex;gap:10px;align-items:center;z-index:200}
  #controls button{padding:8px 10px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:700;cursor:pointer}
  #zoomIn,#zoomOut{padding:6px 10px}

  .q-indicator{width:18px;height:18px;border-radius:50%;background:#444;margin-top:8px;pointer-events:none;border:2px solid #222}
  .q-indicator.on{background:var(--neon);box-shadow:0 0 8px rgba(0,255,102,.45)}

  #brand{position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.06);padding:8px 12px;border-radius:8px;font-weight:900;letter-spacing:1px;z-index:60;box-shadow:0 6px 0 rgba(0,0,0,.04)}

  #installBtn{display:none;position:fixed;right:12px;bottom:80px;z-index:210;background:#003366;color:#fff;border:none;padding:10px 14px;border-radius:10px;font-weight:900;cursor:pointer;box-shadow:0 6px 0 rgba(0,0,0,.12)}

  /* ======= Men√∫ de Biblioteca (arriba izquierda) ======= */
  #libraryBtn{position:fixed;left:12px;top:12px;z-index:220;background:#003366;color:#fff;border:none;padding:10px 12px;border-radius:10px;font-weight:900;cursor:pointer;box-shadow:0 6px 0 rgba(0,0,0,.12)}
  #libraryModal{position:fixed;inset:0;display:none;z-index:230;background:rgba(0,0,0,.35)}
  #librarySheet{position:absolute;left:12px;top:60px;bottom:12px;width:280px;max-width:90vw;background:#fff;border-radius:12px;border:2px solid #003366;box-shadow:0 10px 24px rgba(0,0,0,.2);padding:12px;overflow:auto}
  #librarySheet h3{margin:0 0 10px;font-size:16px;color:#003366}
  #paletteGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
  .pick{background:#fff8dc;border:2px solid #7a7a7a;border-radius:10px;padding:10px;font-weight:800;font-size:18px;text-align:center;cursor:pointer}

  /* Men√∫ contextual del cable */
  #wireMenu{position:fixed;z-index:240;display:none;background:#fff;border:2px solid #00366; border-color:#003366;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.18);overflow:hidden}
  #wireMenu button{display:block;width:100%;background:#fff;border:0;border-bottom:1px solid #e5e5e5;padding:10px 14px;font-weight:800;cursor:pointer;text-align:left}
  #wireMenu button:last-child{border-bottom:0}
  #wireMenu button:hover{background:#f5f9ff}

  /* Modal temporizador */
  #timerModal{position:fixed;inset:0;display:none;z-index:300;background:rgba(0,0,0,.4)}
  #timerCard{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;border-radius:12px;border:2px solid #003366;box-shadow:0 10px 24px rgba(0,0,0,.2);padding:14px;min-width:280px}
  #timerCard h3{margin:0 0 8px;font-size:18px;color:#003366}
  #timerCard label{display:block;font-weight:700;margin-bottom:6px}
  #timerCard input{width:100%;padding:8px;border:2px solid #bbb;border-radius:8px;font-weight:700}
  #timerActions{display:flex;gap:10px;justify-content:flex-end;margin-top:12px}
  #timerActions button{padding:8px 10px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:800;cursor:pointer}
  #btnTimerSave{background:#003366;color:#fff;border-color:#003366}

  @supports(padding:max(0px)){
    #controls{bottom:calc(12px + env(safe-area-inset-bottom))}
    #installBtn{bottom:calc(80px + env(safe-area-inset-bottom))}
  }
</style>
</head>
<body>

  <!-- √Årea de trabajo -->
  <div id="canvas">
    <div id="workspace">
      <svg id="wires" xmlns="http://www.w3.org/2000/svg" width="5000" height="5000" viewBox="0 0 5000 5000" preserveAspectRatio="none"></svg>
    </div>

    <!-- Controles inferiores (igual que antes) -->
    <div id="controls">
      <button id="simulate">Simular</button>
      <button id="stop">Detener</button>
      <button id="deleteBtn">Eliminar</button>
      <button id="zoomOut" title="Alejar">‚àí</button>
      <button id="zoomIn" title="Acercar">Ôºã</button>
    </div>
  </div>

  <!-- Bot√≥n para abrir biblioteca -->
  <button id="libraryBtn">‚ò∞ Bloques</button>

  <!-- Biblioteca modal -->
  <div id="libraryModal" aria-hidden="true">
    <div id="librarySheet">
      <h3>Biblioteca de bloques</h3>
      <div id="paletteGrid"></div>
    </div>
  </div>

  <!-- Marca / PWA -->
  <div id="brand">SIMUPASIR</div>
  <button id="installBtn">Instalar SIMUPASIR</button>

  <!-- Men√∫ contextual del cable -->
  <div id="wireMenu">
    <button id="menuAddNode">‚ûï Crear nodo para acomodar</button>
    <button id="menuMakeLabel">üè∑Ô∏è Crear etiqueta y eliminar cable</button>
  </div>

  <!-- Modal de configuraci√≥n de temporizadores -->
  <div id="timerModal">
    <div id="timerCard">
      <h3 id="timerTitle">Configurar temporizador</h3>
      <label for="timerSec">Tiempo (segundos)</label>
      <input id="timerSec" type="number" min="0" step="0.1" value="1.0" />
      <div id="timerActions">
        <button id="btnTimerCancel">Cancelar</button>
        <button id="btnTimerSave">Guardar</button>
      </div>
    </div>
  </div>

<script>
/* ===== PWA b√°sico ===== */
let deferredPrompt=null;
const installBtn=document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt',(e)=>{ e.preventDefault(); deferredPrompt=e; installBtn.style.display='block'; });
installBtn.addEventListener('click', async()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); await deferredPrompt.userChoice; installBtn.style.display='none'; deferredPrompt=null; });
if('serviceWorker' in navigator){ window.addEventListener('load',()=>{ navigator.serviceWorker.register('./service-worker.js').catch(console.error); }); }

/* ===== SIMUPASIR ===== */
const canvas = document.getElementById("canvas");
const workspace = document.getElementById("workspace");
const wiresSVG = document.getElementById("wires");

let nodes=[], connections=[], pendingOutput=null, pendingGhost=null;
let simulation=false;
let inputCount=0, outputCount=0, memoryCount=0;
let blockCodeCount=0;  // B001, B002, ...
let scale=1, panX=0, panY=0, isPanning=false, panStartX=0, panStartY=0;
let simTimer=null, SCAN_MS=60;
let selectedNode=null, selectedConn=null;
let selectedTag=null;
let selectedBranch=null; // para ramas de etiquetas
let draggingBend=null;
let longPressTimer=null;
let currentToPlace=null;
let selectedPinEl=null;

/* ===== Biblioteca (men√∫) ===== */
const libraryBtn = document.getElementById('libraryBtn');
const libraryModal = document.getElementById('libraryModal');
const paletteGrid = document.getElementById('paletteGrid');
const PALETTE_TYPES = ['input','output','M','and','or','not','nand','nor','xor','xnor','sr','ton','toff'];

function openLibrary(){
  paletteGrid.innerHTML='';
  PALETTE_TYPES.forEach(t=>{
    const b=document.createElement('button');
    b.className='pick';
    b.textContent=t.toUpperCase();
    b.onclick=()=>{ currentToPlace=t; closeLibrary(); };
    paletteGrid.appendChild(b);
  });
  libraryModal.style.display='block';
  libraryModal.setAttribute('aria-hidden','false');
}
function closeLibrary(){
  libraryModal.style.display='none';
  libraryModal.setAttribute('aria-hidden','true');
}
libraryBtn.addEventListener('click', openLibrary);
libraryModal.addEventListener('click', (e)=>{ if(e.target===libraryModal) closeLibrary(); });

/* Hubs (juntas) por pin de salida */
const outputHubs = new WeakMap(); // pinEl -> { x,y, dot, hit, stemPath, branches:Set }

/* ===== Timer config modal ===== */
const timerModal = document.getElementById('timerModal');
const timerTitle = document.getElementById('timerTitle');
const timerSecInput = document.getElementById('timerSec');
const btnTimerCancel = document.getElementById('btnTimerCancel');
const btnTimerSave = document.getElementById('btnTimerSave');
let timerNode=null;

function openTimerModal(node){
  timerNode = node;
  const kind = node.type.toUpperCase();
  const code = node.code || node.name;
  timerTitle.textContent = `Configurar ${kind} (${code})`;
  timerSecInput.value = (node.delayMs ?? 1000) / 1000;
  timerModal.style.display='block';
}
function closeTimerModal(){
  timerModal.style.display='none';
  timerNode=null;
}
btnTimerCancel.addEventListener('click', closeTimerModal);
btnTimerSave.addEventListener('click', ()=>{
  if(!timerNode) return;
  let sec = parseFloat(timerSecInput.value);
  if(isNaN(sec)||sec<0) sec=0;
  timerNode.delayMs = Math.round(sec*1000);
  // reset internos
  timerNode.timerStart=null;
  timerNode.prevIn=0;
  if(timerNode.type==='toff') timerNode.seenHigh=false;
  // actualizar readout al valor fijo
  updateTimerReadout(timerNode, sec);
  closeTimerModal();
});
timerModal.addEventListener('click',(e)=>{ if(e.target===timerModal) closeTimerModal(); });

/* ===== Util ===== */
function zpad(n,len=3){ return String(n).padStart(len,'0'); }
function logoLabelForType(type){
  switch(type){
    case 'and':  return '&';
    case 'nand': return '&';
    case 'or':   return '‚â•1';
    case 'nor':  return '‚â•1';
    case 'not':  return '1';
    case 'xor':  return '=1';
    case 'xnor': return '‚â†1';
    case 'sr':   return 'S/R';
    case 'M':    return 'M';
    case 'ton':  return 'TON';
    case 'toff': return 'TOFF';
    default:     return (type||'').toUpperCase();
  }
}
function clientToWorkspace(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  return { x:(clientX-rect.left-panX)/scale, y:(clientY-rect.top-panY)/scale };
}
function terminalEdge(term){
  const rect = term.getBoundingClientRect();
  const wsRect = workspace.getBoundingClientRect();
  const isInput=term.classList.contains('input');
  const isOutput=term.classList.contains('output');
  const xScreen = isInput ? rect.left : (isOutput ? rect.right : rect.left + rect.width/2);
  const yScreen = rect.top + rect.height/2;
  return { x:(xScreen-wsRect.left)/scale, y:(yScreen-wsRect.top)/scale };
}

/* Zoom & Pan */
canvas.addEventListener("wheel", e=>{ e.preventDefault(); setZoom(scale + (e.deltaY>0?-0.08:0.08)); });
function setZoom(next){
  const rect = canvas.getBoundingClientRect();
  const cx = rect.left+rect.width/2, cy = rect.top+rect.height/2;
  const fx=(cx-rect.left-panX)/scale, fy=(cy-rect.top-panY)/scale;
  const newScale = Math.max(.25, Math.min(3,next));
  panX = cx-rect.left - fx*newScale; panY = cy-rect.top - fy*newScale; scale=newScale;
  updateTransform(); updateConnections();
}
function updateTransform(){ workspace.style.transform=`translate(${panX}px,${panY}px) scale(${scale})`; }
workspace.addEventListener("mousedown", e=>{
  if(e.target===workspace){
    if(e.button===0) clearSelection();
    isPanning=true; panStartX=e.clientX-panX; panStartY=e.clientY-panY;
    document.addEventListener("mousemove",doPan); document.addEventListener("mouseup",endPan);
  }
});
function doPan(e){ if(!isPanning) return; panX=e.clientX-panStartX; panY=e.clientY-panStartY; updateTransform(); updateConnections(); }
function endPan(){ isPanning=false; document.removeEventListener("mousemove",doPan); document.removeEventListener("mouseup",endPan); }

/* Tap para colocar o deseleccionar */
canvas.addEventListener('click', e=>{
  if(e.target===workspace || e.target===wiresSVG){
    if(currentToPlace){
      const pos=clientToWorkspace(e.clientX,e.clientY); createNode(currentToPlace,pos.x,pos.y);
    }else{
      clearSelection();
    }
  }
});

/* Selecci√≥n general */
function selectNode(node){ if(simulation) return; clearSelection(); selectedNode=node; node.el.classList.add('selected'); }
function selectConnection(conn){ if(simulation) return; clearSelection(); selectedConn=conn; conn.selected=true; conn.path?.classList.add('selected'); renderConnection(conn); }
function selectTag(tag){ if(selectedTag===tag) return; selectedTag?.classList.remove('selected'); selectedTag=tag; tag.classList.add('selected'); if(selectedConn){ selectedConn.path?.classList.remove('selected'); selectedConn.selected=false; selectedConn=null; } }
function clearSelection(){
  if(selectedNode){ selectedNode.el.classList.remove('selected'); selectedNode=null; }
  if(selectedConn){ selectedConn.path?.classList.remove('selected'); selectedConn.selected=false; selectedConn=null; }
  if(selectedTag){ selectedTag.classList.remove('selected'); selectedTag=null; }
  if(selectedBranch){ selectedBranch=null; }
  if(selectedPinEl){ selectedPinEl.classList.remove('pin-selected'); selectedPinEl=null; }
  pendingOutput=null; removeGhost(); hideWireMenu();
  if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; }
  connections.forEach(c=>{ (c.handles||[]).forEach(h=>h.remove()); c.handles=[]; });
}

/* Crear bloque */
function createNode(type,x,y){
  const div=document.createElement('div'); div.className='node'; div.style.left=x+'px'; div.style.top=y+'px';

  let display = logoLabelForType(type);
  if(type==='input')  display = `I${++inputCount}`;
  else if(type==='output') display = `Q${++outputCount}`;
  else if(type==='M')      display = `M${++memoryCount}`;

  /* Badge B001... (no para I/Q/M) */
  let blockCode=null;
  if(type!=='input' && type!=='output' && type!=='M'){
    blockCode = 'B'+zpad(++blockCodeCount);
    const badge=document.createElement('div'); badge.className='badge'; badge.textContent=blockCode; div.appendChild(badge);
  }

  const lbl=document.createElement('div'); lbl.className='label'; lbl.textContent=display; div.appendChild(lbl);
  const qind=document.createElement('div'); qind.className='q-indicator off'; div.appendChild(qind);

  const output=document.createElement('div'); output.className='terminal output';
  if(type==='not' || type==='nand' || type==='nor'){ output.classList.add('out-round'); }
  div.appendChild(output);

  const inputs=[];
  if(type==='input'){ div.style.background='#ffe4b5'; }
  else if(type==='output'||type==='M' || type==='ton' || type==='toff'){
    const inp=document.createElement('div'); inp.className='terminal input'; inp.style.top='50%'; div.appendChild(inp); inputs.push(inp);
  } else if(type==='not'){
    const inp=document.createElement('div'); inp.className='terminal input'; inp.style.top='50%'; div.appendChild(inp); inputs.push(inp);
  } else if(type==='sr'){
    const inS=document.createElement('div'); inS.className='terminal input'; inS.style.top='28%';
    const labelS=document.createElement('div'); labelS.className='term-label'; labelS.style.top='24%'; labelS.textContent='S';
    const inR=document.createElement('div'); inR.className='terminal input'; inR.style.top='72%';
    const labelR=document.createElement('div'); labelR.className='term-label'; labelR.style.top='68%'; labelR.textContent='R';
    div.appendChild(inS); div.appendChild(labelS); div.appendChild(inR); div.appendChild(labelR);
    inputs.push(inS); inputs.push(inR);
  }else{
    const nInputs=4;
    for(let i=0;i<nInputs;i++){
      const inp=document.createElement('div'); inp.className='terminal input';
      inp.style.top = `${(i+1)*100/(nInputs+1)}%`;
      div.appendChild(inp); inputs.push(inp);
    }
  }

  workspace.appendChild(div);

  const node={ el:div, type, name:display, code:blockCode, inputs, output, value:0, nextValue:0, qIndicator:qind, invalid:false };

  /* Temporizadores */
  if(type==='ton' || type==='toff'){
    node.delayMs = 1000;     // por defecto 1s
    node.timerStart = null;
    node.prevIn = 0;
    // UI: label peque√±a + readout
    div.classList.add('timer');
    const ro=document.createElement('div'); ro.className='timer-readout'; ro.textContent='t=1.0s';
    div.appendChild(ro);
    node.readout = ro;

    // Doble click/tap para configurar
    div.addEventListener('dblclick', (e)=>{ e.stopPropagation(); openTimerModal(node); });
    let lastTap=0;
    div.addEventListener('touchend', (e)=>{
      const now=e.timeStamp || Date.now();
      if(now - lastTap < 350){ openTimerModal(node); }
      lastTap=now;
    });
  }
  if(type==='toff'){ node.seenHigh=false; }

  if(type==='sr') node.q=0;
  nodes.push(node);

  if(node.output){ node.output.style.top='50%'; node.output.style.transform='translateY(-50%)'; }

  div.addEventListener('click', e=>{ if(e.target.classList.contains('terminal')) return; if(simulation) return; selectNode(node); });
  if(type==='input'){
    div.addEventListener('click', e=>{ if(e.target.classList.contains('terminal')) return; if(!simulation) return; div.classList.toggle('active'); scanLogic(); });
  }

  dragMove(div,node);
  enableConnections(node);
  div.addEventListener('contextmenu', e=>{ e.preventDefault(); if(!simulation) removeNode(node); });

  // readout inicial
  if(node.readout) updateTimerReadout(node, (node.delayMs/1000));

  updateConnections();
}

/* Mover bloque */
function dragMove(el,node){
  let sx,sy,ix,iy,dragging=false;
  el.addEventListener('mousedown', e=>{
    if(e.target.classList.contains('terminal')) return;
    if(simulation) return;
    if(selectedNode!==node) return;
    e.preventDefault(); sx=e.clientX; sy=e.clientY; ix=parseFloat(el.style.left); iy=parseFloat(el.style.top);
    dragging=true; document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
  function onMove(e){ if(!dragging) return; el.style.left=ix+(e.clientX-sx)/scale+'px'; el.style.top=iy+(e.clientY-sy)/scale+'px'; updateConnections(); }
  function onUp(){ dragging=false; document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); }
  el.addEventListener('touchstart', e=>{
    if(simulation) return; if(selectedNode!==node) return;
    const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; ix=parseFloat(el.style.left); iy=parseFloat(el.style.top);
    dragging=true; document.addEventListener('touchmove',onTouchMove,{passive:false}); document.addEventListener('touchend',onTouchEnd);
    e.stopPropagation(); e.preventDefault();
  },{passive:false});
  function onTouchMove(e){ if(!dragging) return; const t=e.changedTouches[0]; el.style.left=ix+(t.clientX-sx)/scale+'px'; el.style.top=iy+(t.clientY-sy)/scale+'px'; updateConnections(); e.preventDefault(); }
  function onTouchEnd(){ dragging=false; document.removeEventListener('touchmove',onTouchMove); document.removeEventListener('touchend',onTouchEnd); }
}

/* Conexiones y pines */
function enableConnections(node){
  const handler = el=>{
    if(simulation) return;
    if(el.classList.contains('output')){
      selectedPinEl?.classList.remove('pin-selected');
      selectedPinEl=el; el.classList.add('pin-selected');
      pendingOutput=el; showGhost(el); return;
    }
    if(el.classList.contains('input')){
      el.classList.add('pin-target'); setTimeout(()=>el.classList.remove('pin-target'),300);
      if(!pendingOutput) return;
      if(pendingOutput===el){ removeGhost(); selectedPinEl?.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null; return; }
      createConnection(pendingOutput, el);
      removeGhost(); selectedPinEl?.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null;
    }
  };
  node.output && node.output.addEventListener('click', ()=>handler(node.output));
  node.inputs.forEach(inp=>inp.addEventListener('click', ()=>handler(inp)));
}

/* Ghost al crear conexi√≥n */
function showGhost(fromTerm){
  removeGhost();
  const s=terminalEdge(fromTerm);
  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("class","wire-path ghost"); updateGhostPath(path,s.x,s.y,s.x,s.y);
  wiresSVG.appendChild(path); pendingGhost=path;
  workspace.addEventListener('mousemove',trackGhost);
  workspace.addEventListener('touchmove',trackGhostTouch,{passive:false});
}
function removeGhost(){
  pendingGhost?.remove(); pendingGhost=null;
  workspace.removeEventListener('mousemove',trackGhost);
  workspace.removeEventListener('touchmove',trackGhostTouch);
}
function trackGhost(e){ if(!pendingGhost||!pendingOutput) return; const p=clientToWorkspace(e.clientX,e.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); }
function trackGhostTouch(e){ if(!pendingGhost||!pendingOutput) return; const t=e.touches[0]; const p=clientToWorkspace(t.clientX,t.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); e.preventDefault(); }
function updateGhostPath(path,sx,sy,ex,ey){ const midX=(sx+ex)/2; path.setAttribute('d',`M${sx},${sy} L${midX},${sy} L${midX},${ey} L${ex},${ey}`); }

/* ===== Helpers etiquetas ===== */
function getSourceName(conn){
  const srcNode = nodes.find(n=>n.output===conn.from);
  if(!srcNode) return '??';
  if(srcNode.type==='input'||srcNode.type==='output'||srcNode.type==='M') return srcNode.name;
  return srcNode.code || 'B???';
}
function getDestNameWithPin(conn){
  const dstNode = nodes.find(n=>n.inputs.includes(conn.to));
  if(!dstNode) return '??';
  const pinIndex = 1 + dstNode.inputs.indexOf(conn.to);
  if(dstNode.type==='input'||dstNode.type==='output'||dstNode.type==='M') return `${dstNode.name}/${pinIndex}`;
  return `${dstNode.code || 'B???'}/${pinIndex}`;
}

/* ===== Hubs (juntas) de salida ===== */
function ensureHub(pinEl){
  let hub = outputHubs.get(pinEl);
  if(hub) return hub;

  const p = terminalEdge(pinEl);
  const x = p.x + 18, y = p.y;
  const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
  dot.setAttribute('cx', x); dot.setAttribute('cy', y); dot.setAttribute('r', 6);
  dot.setAttribute('class','hub-dot');
  const hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
  hit.setAttribute('cx', x); hit.setAttribute('cy', y); hit.setAttribute('r', 18);
  hit.setAttribute('class','hub-hit');

  const stem = document.createElementNS("http://www.w3.org/2000/svg","path");
  stem.setAttribute('class','wire-path');

  wiresSVG.appendChild(stem);
  wiresSVG.appendChild(hit);
  wiresSVG.appendChild(dot);

  const hubObj = { x, y, dot, hit, stemPath:stem, pin:pinEl, branches:new Set() };
  outputHubs.set(pinEl, hubObj);

  const startDrag = (ev)=>{
    ev.stopPropagation();
    const start = (ev.touches? ev.touches[0]:ev);
    const s = clientToWorkspace(start.clientX, start.clientY);
    const ox = hubObj.x, oy = hubObj.y;
    const move = (ev2)=>{
      const cur = (ev2.touches? ev2.touches[0]:ev2);
      const wp = clientToWorkspace(cur.clientX, cur.clientY);
      hubObj.x = ox + (wp.x - s.x);
      hubObj.y = oy + (wp.y - s.y);
      renderHub(hubObj);
    };
    const end = ()=>{
      document.removeEventListener('mousemove',move);
      document.removeEventListener('mouseup',end);
      document.removeEventListener('touchmove',move);
      document.removeEventListener('touchend',end);
    };
    document.addEventListener('mousemove',move);
    document.addEventListener('mouseup',end);
    document.addEventListener('touchmove',move,{passive:false});
    document.addEventListener('touchend',end,{passive:true});
  };
  dot.addEventListener('mousedown',startDrag);
  dot.addEventListener('touchstart',startDrag,{passive:false});
  hit.addEventListener('mousedown',startDrag);
  hit.addEventListener('touchstart',startDrag,{passive:false});

  renderHub(hubObj);
  return hubObj;
}
function renderHub(hub){
  hub.dot.setAttribute('cx', hub.x); hub.dot.setAttribute('cy', hub.y);
  hub.hit.setAttribute('cx', hub.x); hub.hit.setAttribute('cy', hub.y);

  const e = terminalEdge(hub.pin);
  const d = `M${e.x},${e.y} L${hub.x-10},${e.y} L${hub.x-10},${hub.y} L${hub.x},${hub.y}`;
  hub.stemPath.setAttribute('d', d);

  for (const br of hub.branches) renderBranch(br);
}

/* ===== Estructuras de rama/etiqueta ===== */
function createTagEl(text, isSource){
  const tag = document.createElement('div');
  tag.className = 'conn-tag' + (isSource ? ' conn-tag-src' : '');
  tag.textContent = text;
  workspace.appendChild(tag);
  return tag;
}

function attachDragToTag(branch){
  const tag = branch.tagEl;
  let dragging=false, sx=0, sy=0, ox=0, oy=0;
  const start=(ev)=>{
    ev.stopPropagation();
    dragging=true;
    const pt=(ev.touches? ev.touches[0]:ev);
    const wp=clientToWorkspace(pt.clientX, pt.clientY);
    sx=wp.x; sy=wp.y; ox=branch.tx; oy=branch.ty;
    document.addEventListener('mousemove',move);
    document.addEventListener('mouseup',end);
    document.addEventListener('touchmove',move,{passive:false});
    document.addEventListener('touchend',end,{passive:true});
  };
  const move=(ev)=>{
    if(!dragging) return;
    const pt=(ev.touches? ev.touches[0]:ev);
    const wp=clientToWorkspace(pt.clientX, pt.clientY);
    branch.tx = ox + (wp.x - sx);
    branch.ty = oy + (wp.y - sy);
    renderBranch(branch);
    ev.preventDefault?.();
  };
  const end=()=>{
    dragging=false;
    document.removeEventListener('mousemove',move);
    document.removeEventListener('mouseup',end);
    document.removeEventListener('touchmove',move);
    document.removeEventListener('touchend',end);
  };
  tag.addEventListener('mousedown', start);
  tag.addEventListener('touchstart', start, {passive:false});
  tag.addEventListener('click', (e)=>{ e.stopPropagation(); selectTag(tag); });
}

/* Crea una rama desde HUB o desde PIN (entrada) hacia la etiqueta */
function createBranch({fromHub, hub, fromPin, pinEl, text}){
  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute('class','wire-path');
  const hit  = document.createElementNS("http://www.w3.org/2000/svg","path");
  hit.setAttribute('class','wire-hit');

  wiresSVG.appendChild(hit);
  wiresSVG.appendChild(path);

  const tag = createTagEl(text, !!fromHub);

  let start;
  if(fromHub) start = {x:hub.x, y:hub.y};
  else { const e=terminalEdge(pinEl); start = {x:e.x-40, y:e.y}; }

  const branch = {
    fromHub, hub, fromPin, pinEl,
    path, hit, tagEl:tag,
    bends:[],
    tx: start.x + (fromHub? 60 : -60),
    ty: start.y - 20
  };

  const onLP = (ev)=>{
    ev.stopPropagation();
    let cancelled=false;
    const cancel=()=>{ cancelled=true; if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; } document.removeEventListener('mouseup',cancel); document.removeEventListener('touchend',cancel); };
    document.addEventListener('mouseup',cancel,{once:true});
    document.addEventListener('touchend',cancel,{once:true,passive:true});
    longPressTimer=setTimeout(()=>{
      if(cancelled) return;
      const pt=(ev.type==='mousedown')?ev:(ev.touches?.[0] ?? ev);
      const wp=clientToWorkspace(pt.clientX, pt.clientY);
      branch.bends.push({x:wp.x, y:wp.y});
      renderBranch(branch);
    },400);
  };
  path.addEventListener('mousedown', onLP);
  path.addEventListener('touchstart', onLP, {passive:false});
  hit .addEventListener('mousedown', onLP);
  hit .addEventListener('touchstart', onLP, {passive:false});

  attachDragToTag(branch);
  renderBranch(branch);

  const onSel=(e)=>{ e.stopPropagation(); selectedBranch=branch; selectTag(tag); };
  hit.addEventListener('click', onSel);
  hit.addEventListener('touchstart', onSel, {passive:true});

  return branch;
}

/* Render de una rama */
function renderBranch(branch){
  const sx = branch.fromHub ? branch.hub.x : terminalEdge(branch.pinEl).x;
  const sy = branch.fromHub ? branch.hub.y : terminalEdge(branch.pinEl).y;

  const ex = branch.tx, ey = branch.ty;

  let d='';
  if(branch.bends.length===0){
    const midX=(sx+ex)/2; d=`M${sx},${sy} L${midX},${sy} L${midX},${ey} L${ex},${ey}`;
  }else{
    const pts=[{x:sx,y:sy}].concat(branch.bends).concat([{x:ex,y:ey}]);
    d=`M${pts[0].x},${pts[0].y} `; for(let i=1;i<pts.length;i++){ const prev=pts[i-1], next=pts[i]; d+=`L${next.x},${prev.y} L${next.x},${next.y} `; }
  }
  branch.path.setAttribute('d', d);
  branch.hit.setAttribute('d', d);

  branch.tagEl.style.left = ex + 'px';
  branch.tagEl.style.top  = ey + 'px';
}

/* Convertir cable a etiquetas + hub */
function convertWireToLabel(conn){
  conn.path && conn.path.remove(); conn.path=null;
  conn.hit && conn.hit.remove(); conn.hit=null;
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];

  const srcName = getDestNameWithPin(conn);
  const inName  = getSourceName(conn);

  const hub = ensureHub(conn.from);
  const srcBranch = createBranch({fromHub:true, hub, text:srcName});
  hub.branches.add(srcBranch);
  conn.srcBranch = srcBranch;

  const dstBranch = createBranch({fromHub:false, pinEl:conn.to, text:inName});
  conn.dstBranch = dstBranch;

  conn.mode = 'label';
  renderConnection(conn);
}

/* Crear conexi√≥n normal */
function createConnection(fromTerm,toTerm){
  if(simulation) return;
  if(connections.find(c => c.from===fromTerm && c.to===toTerm)) return;
  const conn={ from:fromTerm, to:toTerm, path:null, hit:null, bends:[], handles:[], selected:false, mode:'wire',
               srcBranch:null, dstBranch:null };
  connections.push(conn); renderConnection(conn);
}

/* Men√∫ contextual en cables */
const wireMenu = document.getElementById('wireMenu');
const menuAddNode = document.getElementById('menuAddNode');
const menuMakeLabel = document.getElementById('menuMakeLabel');
let menuContext = { conn:null, clientX:0, clientY:0 };

function showWireMenu(conn, clientX, clientY){
  menuContext = { conn, clientX, clientY };
  wireMenu.style.display='block';
  const vw = window.innerWidth, vh = window.innerHeight;
  const menuW = 260, menuH = 90;
  let x = clientX, y = clientY;
  if(x + menuW > vw) x = vw - menuW - 8;
  if(y + menuH > vh) y = vh - menuH - 8;
  wireMenu.style.left = x + 'px';
  wireMenu.style.top  = y + 'px';
}
function hideWireMenu(){ wireMenu.style.display='none'; }
menuAddNode.addEventListener('click', ()=>{
  const {conn, clientX, clientY} = menuContext;
  hideWireMenu();
  if(!conn) return;
  const pos=clientToWorkspace(clientX, clientY);
  conn.bends.push({x:pos.x,y:pos.y}); selectConnection(conn); renderConnection(conn);
});
menuMakeLabel.addEventListener('click', ()=>{
  const {conn} = menuContext;
  hideWireMenu();
  if(!conn) return;
  convertWireToLabel(conn);
});
document.addEventListener('click', (e)=>{ if(e.target!==wireMenu && !wireMenu.contains(e.target)) hideWireMenu(); });

/* ===== Se√±al visual pines/etiquetas/ramas/hub ===== */
function applySignalStyles(conn, val){
  try{
    conn.from.classList.toggle('signal-on', val===1);
    conn.to.classList.toggle('signal-on',   val===1);
  }catch(e){}

  if(conn.mode==='label'){
    if(conn.srcBranch){
      conn.srcBranch.path.classList.toggle('signal', val===1);
      conn.srcBranch.tagEl.classList.toggle('signal', val===1);
    }
    if(conn.dstBranch){
      conn.dstBranch.path.classList.toggle('signal', val===1);
      conn.dstBranch.tagEl.classList.toggle('signal', val===1);
    }
    const hub = outputHubs.get(conn.from);
    if(hub){
      hub.stemPath.classList.toggle('signal', val===1);
      hub.dot.classList.toggle('signal', val===1);
    }
  }else{
    if(conn.path) conn.path.classList.toggle('signal', val===1);
  }

  const srcNode=nodes.find(n=>n.output===conn.from);
  if(srcNode){
    srcNode.qIndicator && srcNode.qIndicator.classList.toggle('on', val===1);
    srcNode.el.classList.toggle('has-signal', srcNode.value===1);
  }
  const dstNode=nodes.find(n=>n.inputs.includes(conn.to));
  if(dstNode){
    dstNode.el.classList.toggle('has-signal', dstNode.value===1);
  }
}

/* Render conexi√≥n */
function renderConnection(conn){
  if(conn.mode==='label'){
    if(conn.srcBranch) renderBranch(conn.srcBranch);
    if(conn.dstBranch) renderBranch(conn.dstBranch);
    const hub = outputHubs.get(conn.from);
    hub && renderHub(hub);
    const val = getSourceNodeValue(conn);
    applySignalStyles(conn, val);
    return;
  }

  conn.path?.remove(); conn.hit?.remove();
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];

  const s=terminalEdge(conn.from), e=terminalEdge(conn.to);
  let d='';
  if(conn.bends.length===0){
    const midX=(s.x+e.x)/2; d=`M${s.x},${s.y} L${midX},${s.y} L${midX},${e.y} L${e.x},${e.y}`;
  }else{
    const pts=[{x:s.x,y:s.y}].concat(conn.bends).concat([{x:e.x,y:e.y}]);
    d=`M${pts[0].x},${pts[0].y} `; for(let i=1;i<pts.length;i++){ const prev=pts[i-1], next=pts[i]; d+=`L${next.x},${prev.y} L${next.x},${next.y} `; }
  }

  const hit=document.createElementNS("http://www.w3.org/2000/svg","path");
  hit.setAttribute("d",d); hit.setAttribute("class","wire-hit");

  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d",d); path.setAttribute("class","wire-path");
  if(conn.selected) path.classList.add('selected');

  const val=getSourceNodeValue(conn);

  const onSelect=(ev)=>{ ev.stopPropagation(); if(simulation) return; selectConnection(conn); };
  hit.addEventListener('click',onSelect);
  hit.addEventListener('touchstart',onSelect,{passive:true});
  hit.addEventListener('contextmenu',(ev)=>{ ev.preventDefault(); if(simulation) return; showWireMenu(conn, ev.clientX, ev.clientY); });

  function onPathDown(ev){
    if(simulation) return;
    if(ev.type==='mousedown' && ev.button!==0) return;
    ev.stopPropagation();
    let cancelled=false;
    const cancel=()=>{ cancelled=true; if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; } document.removeEventListener('mouseup',cancel); document.removeEventListener('touchend',cancel); };
    document.addEventListener('mouseup',cancel,{once:true});
    document.addEventListener('touchend',cancel,{once:true,passive:true});
    longPressTimer=setTimeout(()=>{
      if(cancelled) return;
      const clientX=(ev.type==='mousedown')?ev.clientX:(ev.touches?.[0]?.clientX ?? ev.clientX);
      const clientY=(ev.type==='mousedown')?ev.clientY:(ev.touches?.[0]?.clientY ?? ev.clientY);
      showWireMenu(conn, clientX, clientY);
    },400);
  }
  path.addEventListener('mousedown',onPathDown);
  path.addEventListener('touchstart',onPathDown,{passive:false});
  hit .addEventListener('mousedown',onPathDown);
  hit .addEventListener('touchstart',onPathDown,{passive:false});

  wiresSVG.appendChild(hit);
  wiresSVG.appendChild(path);
  conn.hit=hit; conn.path=path;

  applySignalStyles(conn, val);

  if(conn.selected && !simulation){
    conn.handles=[];
    conn.bends.forEach((b,idx)=>{
      const g=document.createElementNS("http://www.w3.org/2000/svg","g");
      const hitC=document.createElementNS("http://www.w3.org/2000/svg","circle");
      hitC.setAttribute('cx',b.x); hitC.setAttribute('cy',b.y); hitC.setAttribute('r',24); hitC.setAttribute('class','bend-hit');
      const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute('cx',b.x); c.setAttribute('cy',b.y); c.setAttribute('r',11); c.setAttribute('class','bend-handle');
      g.appendChild(hitC); g.appendChild(c); wiresSVG.appendChild(g);
      conn.handles.push(c);
      const start=(ev)=>{ if(simulation) return; ev.stopPropagation(); startDraggingHandle(conn, idx); };
      c.addEventListener('mousedown',start); c.addEventListener('touchstart',start,{passive:true});
      hitC.addEventListener('mousedown',start); hitC.addEventListener('touchstart',start,{passive:true});
    });
  }
}

/* Bend dragging */
function startDraggingHandle(conn,index){
  if(conn.handles && conn.handles[index]) conn.handles[index].classList.add('dragging');
  draggingBend={conn,index};
  document.addEventListener('mousemove',onBendMove);
  document.addEventListener('mouseup',stopDraggingHandle);
  document.addEventListener('touchmove',onBendMoveTouch,{passive:false});
  document.addEventListener('touchend',stopDraggingHandle,{passive:true});
}
function stopDraggingHandle(){
  if(!draggingBend) return;
  const {conn,index}=draggingBend;
  if(conn.handles && conn.handles[index]) conn.handles[index].classList.remove('dragging');
  draggingBend=null;
  document.removeEventListener('mousemove',onBendMove);
  document.removeEventListener('mouseup',stopDraggingHandle);
  document.removeEventListener('touchmove',onBendMoveTouch);
  document.removeEventListener('touchend',stopDraggingHandle);
}
function onBendMove(ev){
  if(!draggingBend) return;
  const pos=clientToWorkspace(ev.clientX,ev.clientY);
  const {conn,index}=draggingBend;
  conn.bends[index].x=pos.x; conn.bends[index].y=pos.y;
  renderConnection(conn);
}
function onBendMoveTouch(ev){
  if(!draggingBend) return; ev.preventDefault();
  const t=ev.touches[0]; const pos=clientToWorkspace(t.clientX,t.clientY);
  const {conn,index}=draggingBend;
  conn.bends[index].x=pos.x; conn.bends[index].y=pos.y;
  renderConnection(conn);
}

/* Utilidades */
function getSourceNodeValue(conn){ const n=nodes.find(nn=>nn.output===conn.from); return n? n.value:0; }
function updateConnections(){ connections.forEach(c=>renderConnection(c)); }

/* Eliminar bloque + cables asociados y limpiar hubs */
function removeNode(node){
  if(simulation) return;

  if(selectedPinEl && (selectedPinEl===node.output || node.inputs.includes(selectedPinEl))){
    selectedPinEl.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null; removeGhost();
  }
  const toRemove = connections.filter(c=> c.from===node.output || node.inputs.includes(c.to) );
  toRemove.forEach(removeConnection);

  if(node.output){
    const hub = outputHubs.get(node.output);
    if(hub){
      for(const br of hub.branches){
        br.tagEl.remove(); br.path.remove(); br.hit.remove();
      }
      hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
      outputHubs.delete(node.output);
    }
  }

  node.el.remove();
  nodes = nodes.filter(n=>n!==node);

  clearSelection();
  updateConnections();
}

/* Eliminar conexi√≥n (wire o label) */
function removeConnection(conn){
  if(!conn) return;
  conn.path && conn.path.remove(); conn.hit && conn.hit.remove();
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];

  if(conn.srcBranch){
    const hub = conn.srcBranch.hub;
    if(hub){ hub.branches.delete(conn.srcBranch); }
    conn.srcBranch.tagEl.remove(); conn.srcBranch.path.remove(); conn.srcBranch.hit.remove();
    conn.srcBranch=null;
    if(hub && hub.branches.size===0){
      hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
      outputHubs.delete(hub.pin);
    }
  }
  if(conn.dstBranch){
    conn.dstBranch.tagEl.remove(); conn.dstBranch.path.remove(); conn.dstBranch.hit.remove();
    conn.dstBranch=null;
  }

  const i=connections.indexOf(conn); if(i>=0) connections.splice(i,1);
  if(selectedConn===conn) selectedConn=null;
  if(selectedTag && (selectedTag===conn.tagSrcEl || conn.tagDstEl===selectedTag)){ selectedTag.classList.remove('selected'); selectedTag=null; }
}

/* ===== Temporizadores: helper de readout ===== */
function updateTimerReadout(node, seconds){
  if(!node.readout) return;
  const s = Math.max(0, seconds);
  node.readout.textContent = (node.isCounting ? s.toFixed(1)+'s' : ('t='+s.toFixed(1)+'s'));
}

/* ===== L√≥gica de compuertas y temporizadores ===== */
function evaluateGate(type,inputs){
  if(inputs.length===0) return 0;
  switch(type){
    case 'and': return inputs.every(v=>v===1)?1:0;
    case 'or':  return inputs.some(v=>v===1)?1:0;
    case 'not': return inputs[0]?0:1;
    case 'nand':return inputs.every(v=>v===1)?0:1;
    case 'nor': return inputs.some(v=>v===1)?0:1;
    case 'xor': return inputs.reduce((a,b)=>a^b,0);
    case 'xnor':return evaluateGate('xor',inputs)?0:1;
    default: return inputs[0]||0;
  }
}
function nowMs(){ return performance.now ? performance.now() : Date.now(); }

function scanLogic(){
  const tnow = nowMs();

  // entradas
  nodes.forEach(n=>{
    if(n.type==='input') n.value = n.el.classList.contains('active')?1:0;
    n.invalid=false;
  });

  // calcular nextValue
  nodes.forEach(node=>{
    if(node.type==='input'){ node.nextValue=node.value; return; }

    const inVals=connections.filter(c=>node.inputs.includes(c.to)).map(c=>{
      const s=nodes.find(n=>n.output===c.from); return s ? s.value : 0;
    });
    const in0 = inVals[0]??0;

    if(node.type==='output' || node.type==='M'){
      node.nextValue=in0?1:0;
    } else if(node.type==='sr'){
      const S=inVals[0]?1:0, R=inVals[1]?1:0;
      if(S===1 && R===0){ node.q=1; node.nextValue=1; }
      else if(S===0 && R===1){ node.q=0; node.nextValue=0; }
      else node.nextValue=node.q||0;
    } else if(node.type==='ton'){
      const delay = node.delayMs ?? 1000;
      if(in0===1){
        if(node.timerStart==null) node.timerStart = tnow;
        const elapsed = tnow - node.timerStart;
        node.isCounting = elapsed < delay;
        node.nextValue = node.isCounting ? 0 : 1;
        const remaining = Math.max(0, delay - elapsed)/1000;
        updateTimerReadout(node, node.isCounting ? remaining : delay/1000);
      }else{
        node.timerStart = null;
        node.isCounting = false;
        node.nextValue = 0;
        updateTimerReadout(node, (node.delayMs??1000)/1000);
      }
      node.prevIn = in0;
    } else if(node.type==='toff'){
      const delay = node.delayMs ?? 1000;
      if(in0===1){
        node.seenHigh = true;
        node.timerStart = null;       // cancela conteo off
        node.isCounting = false;
        node.nextValue = 1;
        updateTimerReadout(node, delay/1000);
      }else{ // in0 == 0
        if(!node.seenHigh){
          node.nextValue = 0;
          node.timerStart = null;
          node.isCounting = false;
          updateTimerReadout(node, delay/1000);
        }else{
          if(node.timerStart==null) node.timerStart = tnow;
          const elapsed = tnow - node.timerStart;
          const remaining = Math.max(0, delay - elapsed)/1000;
          node.isCounting = remaining > 0;
          node.nextValue = node.isCounting ? 1 : 0;
          updateTimerReadout(node, node.isCounting ? remaining : delay/1000);
        }
      }
      node.prevIn = in0;
    } else {
      node.nextValue=evaluateGate(node.type,inVals)?1:0;
    }
  });

  // fijar values
  nodes.forEach(n=>{ n.value=n.nextValue; if(n.type==='sr') n.q=n.nextValue; });

  // visual de bloques
  nodes.forEach(n=>{
    n.el.classList.toggle('has-signal', n.value===1);
    if(n.type==='input' || n.type==='output' || n.type==='M'){
      n.el.classList.toggle('active', n.value===1);
      n.output && n.output.classList.toggle('signal-on', n.value===1);
    }
    n.qIndicator && n.qIndicator.classList.toggle('on', n.value===1);
  });

  // actualizar conexiones
  connections.forEach(c=>{
    const v=getSourceNodeValue(c);
    applySignalStyles(c, v);
  });

  updateConnections();
}

/* Botones */
document.getElementById('simulate').addEventListener('click', ()=>{
  if(simulation) return;
  clearSelection(); simulation=true;
  // reset internos de temporizadores
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      n.timerStart = null;
      n.prevIn = 0;
      n.isCounting=false;
      if(n.type==='toff') n.seenHigh=false;
      if(n.readout) updateTimerReadout(n, (n.delayMs??1000)/1000);
    }
  });
  scanLogic(); simTimer=setInterval(scanLogic,SCAN_MS);
});
document.getElementById('stop').addEventListener('click', ()=>{
  if(simTimer){ clearInterval(simTimer); simTimer=null; }
  simulation=false;
  nodes.forEach(n=>{
    n.value=0;
    n.el.classList.remove('has-signal','active');
    if(n.type==='input'||n.type==='output'||n.type==='M') n.el.classList.remove('active');
    n.qIndicator && n.qIndicator.classList.remove('on');
    n.invalid=false;
    n.output && n.output.classList.remove('signal-on');
    n.inputs?.forEach(inp=>inp.classList.remove('signal-on'));
    if(n.type==='ton' || n.type==='toff'){
      n.timerStart=null; n.prevIn=0; n.isCounting=false;
      if(n.type==='toff') n.seenHigh=false;
      if(n.readout) updateTimerReadout(n, (n.delayMs??1000)/1000);
    }
  });
  connections.forEach(c=>applySignalStyles(c, 0));
  updateConnections();
});
document.getElementById('deleteBtn').addEventListener('click', ()=>{
  if(simulation) return;
  if(selectedNode){ removeNode(selectedNode); return; }
  if(selectedConn){ removeConnection(selectedConn); updateConnections(); return; }
  if(selectedTag && selectedBranch){
    const conn = connections.find(c=> c.srcBranch===selectedBranch || c.dstBranch===selectedBranch );
    if(conn){
      if(conn.srcBranch===selectedBranch){
        const hub = selectedBranch.hub;
        hub && hub.branches.delete(selectedBranch);
        selectedBranch.tagEl.remove(); selectedBranch.path.remove(); selectedBranch.hit.remove();
        conn.srcBranch=null;
        if(hub && hub.branches.size===0){
          hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
          outputHubs.delete(hub.pin);
        }
      }else if(conn.dstBranch===selectedBranch){
        selectedBranch.tagEl.remove(); selectedBranch.path.remove(); selectedBranch.hit.remove();
        conn.dstBranch=null;
      }
      if(!conn.srcBranch && !conn.dstBranch){
        const i=connections.indexOf(conn); if(i>=0) connections.splice(i,1);
      }
      updateConnections();
    }
    selectedBranch=null; selectedTag=null;
    return;
  }
  if(selectedTag){
    for(const conn of connections){
      if(conn.srcBranch && conn.srcBranch.tagEl===selectedTag){ selectedBranch=conn.srcBranch; break; }
      if(conn.dstBranch && conn.dstBranch.tagEl===selectedTag){ selectedBranch=conn.dstBranch; break; }
    }
    document.getElementById('deleteBtn').click();
  }
});

/* Teclas + zoom */
document.getElementById('zoomIn').addEventListener('click', ()=>setZoom(scale+0.12));
document.getElementById('zoomOut').addEventListener('click', ()=>setZoom(scale-0.12));
document.addEventListener('keydown', (e)=>{
  if(e.key==='Delete' || e.key==='Backspace'){
    if(simulation) return;
    document.getElementById('deleteBtn').click();
  }
  if(e.key==='Escape'){ clearSelection(); }
});

/* Redibuja en resize */
window.addEventListener('resize', updateConnections);

/* Init */
function updateConnections(){ connections.forEach(c=>renderConnection(c)); }
function removeGhost(){ if(pendingGhost){ pendingGhost.remove(); pendingGhost=null; } }
function showGhost(fromTerm){
  removeGhost();
  const s=terminalEdge(fromTerm);
  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("class","wire-path ghost"); updateGhostPath(path,s.x,s.y,s.x,s.y);
  wiresSVG.appendChild(path); pendingGhost=path;
  workspace.addEventListener('mousemove',trackGhost);
  workspace.addEventListener('touchmove',trackGhostTouch,{passive:false});
}
function trackGhost(e){ if(!pendingGhost||!pendingOutput) return; const p=clientToWorkspace(e.clientX,e.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); }
function trackGhostTouch(e){ if(!pendingGhost||!pendingOutput) return; const t=e.touches[0]; const p=clientToWorkspace(t.clientX,t.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); e.preventDefault(); }
function updateGhostPath(path,sx,sy,ex,ey){ const midX=(sx+ex)/2; path.setAttribute('d',`M${sx},${sy} L${midX},${sy} L${midX},${ey} L${ex},${ey}`); }

updateConnections();
console.log("SIMUPASIR: TON/TOFF con readout en segundos y biblioteca en men√∫.");
</script>
</body>
</html>
